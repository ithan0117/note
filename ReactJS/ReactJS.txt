一. Hello World
	IDE
		1. codepen : https://codepen.io/gaearon/pen/ZpvBNJ
		2. Babel REPL : http://babeljs.io/repl/
		3. local
		
	cdn
		https://reactjs.org/docs/cdn-links.html有說明
		*註 : 開發版才有完整的錯誤訊息
		
	注意事項 : 常用ES6(arrow function、class、let、const)
	
	名詞
		React元素 : React中的最小單位, 程式面來看是普通物件
		組件 : 由React元素組成, 程式面來看是純函數或類別
		<HTML元素> --> <React元素> --> 組件

		*註 : React元素為組件的回傳值
		
	簡單範例 (without JSX、npm)
		index.html
			<!DOCTYPE html>
			<html lang="en">
			<head>
				<meta charset="UTF-8">
				<title>Index</title>
				<script crossorigin src="https://unpkg.com/react@16/umd/react.development.js"></script>
				<script crossorigin src="https://unpkg.com/react-dom@16/umd/react-dom.development.js"></script>
			</head>
			<body>
				<div id="root"></div>
			</body>
			</html>
			<script src="index.js"></script>
		
		
		index.js
			function Welcome(props) {
				return React.createElement(
					"div",
					null,
					`hi, ${props.name}`
				);
			}

			ReactDOM.render(
				Welcome({name : "william"}),
				document.getElementById("root")
			);

二. JSX
	簡述 : JavaScript 的語法擴展, 用來聲明React當中的元素. 在編譯之後呢, JSX 其實會被轉化為普通的JavaScript表達式
	
	注意事項
		1. HTML的單標籤轉成JSX都需加上斜線, ex. <br />、<input type="submit" />
		2. 整個JSX : 放在小括號裡, 以防止分號自動插入的bug
			ex.
				const element = (<div>hi, </div>);
				
		3. JavaScript表達式 : 在JSX中使用時, 需包含在大括號裡
			ex.
				const element = (<div>hi, {p1.name}</div>);

		4. 屬性值
			4.1 字串型態 : "值"
				ex.
					const element = (<div value="abc">...</div>);

			4.2 其他型態 : {JavaScript表達式}
				ex.
					const element = (<div value={p1.name}>...</div>);

		5. 屬性命名 : 小駝峰
		
		6. 防止XSS : 所以要呈現的東西, 在渲染前都會轉成字串

		7. 編譯時期的底層動作
			7.1 Babel轉譯器會把JSX轉換成一個名為React.createElement()的方法呼叫
				ex.
					const element = (<div value="abc">hi</div>);
					等同
					const element = React.createElement("div", {value : "abc"}, "hi");

			7.2 React.createElement()會進行一些避免bug的檢查, 並回傳一個物件
				ex. 
					{
						type : "div",
						props : {
							value : "abc",
							children : "hi"
						}
					}

三. 元素渲染
	簡述 : React元素是構成React應用的最小單位, 即描述你在屏幕上看到的內容.
		   事實上是普通的物件, React DOM 可以確保瀏覽器DOM 的數據內容與React 元素保持一致

	*註
		1. React元素在此皆簡稱為元素
		2. "元素"跟"組件"是不同的東西, 組件是由元素所組成
	
	注意事項
		1. 根元素 : ex. <div id="root"></div>, 將由React DOM 來管理. 一般只會定義一個根節點
		
		2. 渲染 : 透過ReactDOM.render(元素, 根元素)
		
		3. immutable不可變的 : 元素被創建之後, 你是無法改變其內容或屬性, 它代表應用界面在某一時間點的樣子

		4. 可配合setInterval()等函數使用
			ex.
				function showDate() {
					function Test() {
						const elt1 = (<div>{new Date().toLocaleTimeString()}</div>)
						return elt1;
					}

					ReactDOM.render(<Test />, document.getElementById("root"));
				}

				setInterval(showDate, 1000);

			*註 : 多數React應用只會調用一次ReactDOM.render()
		
		5. 局部更新 : React DOM 首先會比較元素內容先後的不同, 而在渲染過程中只會更新改變了的部分


四. 組件& Props
	簡述 : 從UI的觀念來看, 組件是將UI切分成一些的獨立的、可複用的部件; 從程式面來看它是一個函數, 可接收參數(props), 並回傳React元素

	定義
		*註
			1. 組件名以大寫開頭
			2. 兩種方式的回傳React元素 都可以配合 JSX 或 React.createElement() 來使用
			3. 當React遇到元素是自定義的組件, 他會將其內的屬性紀錄在props特性
	
		方式1 - 函數式
			語法
				function 組件名(props) {
					...
					return React元素;
				}

			範例
				// with JSX
				function Square(props) {
					return (
						<button className="square" onClick={props.onClick}>
							Submit
						</button>
					);
				}
				
				// with React.createElement()
				function Square(props) {
					return React.createElement(
						"button",
						{className : "elt1", onClick : props.onClick},
						"Submit"
					)	
				}
					
		方式2 - 類別式
			語法
				class 組件名 extends React.Component {
					render() {
						return React元素;
					}
				}

			範例
				// with JSX
				class Square extends React.Component {
					render() {
						return (
							<button className="square" onClick={props.onClick}>
								Submit
							</button>
						);
					}
				}

				// with React.createElement()
				class Square extends React.Component {
					render() {
						return React.createElement(
							"button",
							{className : "elt1", onClick : props.onClick},
							"Submit"
						)
					}
				}

	組合組件
		簡述 : 組件可巢狀包含, 形成新的組件

		*註 : 通常一個React程式頂端會是一個App組件

		範例
			function Square(props) {
				return (
					<button className="square" onClick={props.onClick}>
						{props.text}
					</button>
				);
			}

			function App(props) {
				return (
					<div>
						<Square text={props.text[0]} />
						<Square text={props.text[1]} />
						<Square text={props.text[0]} />
					</div>
				);
			}

			ReactDOM.render(
				<App name={["Submit", "Confirm", "Cancel"]} />,
				document.getElementById("root")
			);

	Props的不可變性 : 同純函數特性
		
			
五. State & 生命週期
	state特點
		1. state跟props很像
		2. state是私有的, 只在當前組件; props則是由別處傳來
		3. 只限用在class定義方式
		4. 在類別中用 this.state 存取
		5. 不用在render()中的東西, 就不應該儲存在state
		6. 非建構子中更新state : 使用this.setState()
			6.1 跟props無關 : this.setState(狀態物件)
				ex.
					this.setState({date : new Date()});
					
			6.2 跟props有關 : this.setState((原狀態, props) => {})
				*註 : 因為狀態更新可能是在非同步的狀況下, 所以需用"函數"
				ex.
					this.setState((prevState, props) => {
						counter: prevState.counter + props.step;
					});
					
			*註 : this.setState()會"單獨更新"有指定到的部分, 意義上比較像"updateState"
	
		7. 外部無法知道是否有state
	
	生命週期特點
		1. 建構子 : construtor(), 在被實例化時執行, 唯一能初始化的地方
		2. 掛載方法 : componentDidMount(), 在第一次被加入UI時執行
		3. 卸載方法 : componentWillUnmount(), 在從UI中移除時執行
		4. 2跟3兩方法被稱為lifecycle hooks(鉤)
			
			
	範例
		class Clock extends React.Component {
		
			// 建構子
			constructor(props) {
				super(props);
				this.state = {date : new Date()};	// 初始化state
			}
			
			// 掛載方法
			componentDidMount() {
				this.timerId = setInterval(
					() => {this.setState({date : new Date()});},	// 更新state
					1000
				);
			}
  
			// 卸載方法
			componentWillUnmount() {
				clearInterval(this.timerId);
			}
  
			render() {
				return (
					<div>{this.state.date.toTimeString()}</div>
				);
			}
		}
			
			
六. 事件處理
	注意
		1. 寫法 : 與HTML DOM事件處理很相似
		2. 命名 : 屬性命名使用小駝峰式
		3. 註冊 : 使用JSX時, 指定代表函數的變數名, 非字串
			ex.
				<button onClick="{processor}">Submit</button>
			
		4. 取消預設行為 : 需用e.preventDefault(), 不可用return false
		5. React的事件物件 : 事件處理器的參數, 是一個合成事件(SyntheticEvent), 已含跨瀏覽器兼容性
			
	建立步驟
		0. 建立一類別
		
		1. 定義處理器 : 在類別裡定義一函式
		
		2. 把this注入處理器
			*註 : 類別的方法預設不會注入this, 需手動把this注入進去
		
			方式1 - 使用 bind() (in constructor)
				class 類別名 extends React.Component {
			
					constructor() {
						...
						this.處理器名 = this.處理器名.bind(this);	// <--
					}
					
					處理器名() {
						...
					}
					
					...
				}
			
			方式2 - 使用 屬性初始化器(Property initializer)
				*註 : 此語法還屬於實驗性(??). 若使用create-react-app會自動開啟此語法支援
				
				class 類別名 extends React.Component {
			
					處理器名 = () => {		// <--
						...
					}
					
					...
				}
				
			方式3 - 多包一層函數 (在註冊時)
				*註 : 此種方式每次渲染時都會新建一個callback函數, 效能較低
			
				<標籤 事件屬性={(e) => this.處理器名(e)} >
				
				ex.
					<button onClick={(e) => this.handleClick(e)}>	// 假設已先定義handleClick()
			
		3. 註冊
		
	範例
		class Toggle extends React.Component {
			constructor(props) {
				super(props);
				this.state = {isToggleOn : true};
				
				// 步驟2 : bind()
				this.handleClick = this.handleClick.bind(this);
			}
			
			// 步驟1 : 定義
			handleClick(e) {
				this.setState((prevState) => {
					{isToggleOn: !prevState.isToggleOn};
				});
			
			}
			
			render() {
				return (
					// 步驟3 : 註冊
					<button onClick={this.handleClick}>
						{this.state.isToggleOn ? "ON" : "OFF"}
					</button>
				);
			}
		}
		
	事件處理器的參數
		預設參數 : 不需指定, 自動會被傳遞
			e : React事件物件
			
			範例
				<button onClick={this.deleteAll}>Submit</button>
				
				deleteAll(e) {
					...
				}
		
		額外參數
			方式1 -  多包一層函數 (在註冊時)
				*註 : e的順序自訂, 只需傳送跟接收兩端配合
				
				語法
					傳送
						<標籤 事件屬性={(e) => this.處理器名(額外參數1, 額外參數2, ..., 額外參數N, e)} >
						
					接收
						處理器名(額外參數1, 額外參數2, ..., 額外參數N, e)
						
				範例
					<button onClick={(e) => this.deleteById(id, e)}>Submit</button>
					
					deleteById(id, e) {
						...
					}
		
			方式2 - 使用 bind() (在註冊時)
				*註 : e會"自動"被加在"最後"一個參數
				
				語法
					傳送
						<標籤 事件屬性={this.處理器名.bind(this, 額外參數1, 額外參數2, ..., 額外參數N)} >
						
					接收
						處理器名(額外參數1, 額外參數2, ..., 額外參數N, e) {
							...
						}
					
				範例
					<button onClick={this.deleteById.bind(this, id)}>Submit</button>

					deleteById(id, e) {
						...
					}


七. 條件渲染
	簡述 : 根據狀態局部渲染

	常用指令
		if
		&&
		三元運算子

	範例 - if
		function GuestGreeting() {
			return (
				<h1>Please sign up</h1>
			);
		}

		function UserGreeting(props) {
			return (
				<h1>Welcome back, {props.name}</h1>
			);
		}

		function Greeting(props) {
			const isLoggedIn = props.isLoggedIn;

			if (isLoggedIn) {
				return <UserGreeting name={props.name}/>;
			}
			return <GuestGreeting />;
		}

		ReactDOM.render(
			<Greeting isLoggedIn={true} name="william" />,
			root
		);

	範例 - &&
		function Mailbox(props) {
			const unreadMsg = props.unreadMsg;

			return (
				<div>
					Hey {props.name}
					{unreadMsg.length > 0 &&
						<h2>You have {unreadMsg.length} unread Message.</h2>}
				</div>
			);
		}

		const msg = ["C", "C++", "C#", "Java", "ASP", "SQL", "Android", "JavaScript", "Scala"];

		ReactDOM.render(
			<Mailbox name="william" unreadMsg={msg} />,
			root
		);
	
	範例 - 三元運算子
		function GuestGreeting() {
			return (
				<h1>Please sign up</h1>
			);
		}

		function UserGreeting(props) {
			return (
				<h1>Welcome back, {props.name}</h1>
			);
		}

		function Greeting(props) {
			const isLoggedIn = props.isLoggedIn;

			return isLoggedIn ? <UserGreeting name={props.name}/> : <GuestGreeting />;
			 
		}

		ReactDOM.render(
			<Greeting isLoggedIn={true} name="william" />,
			root
		);
	
	
	阻止渲染
		簡述 : 某些狀況下會需要"隱藏"組件
	
		方式 : render()回傳null
		
		注意 : 並不會影響組件的生命週期方法的回呼 (ex. componentWillUpdate()、componentDidUpdate() ..)
			
		範例
			function User(props) {
				if (!props.isLoggedIn) {
					return null;
				}
				return (
					<div>{props.name}</div>
				);
			}
	
	
八. 列表 & Keys

	用途 : React底層在增加或刪除元素時, 比對演算法需要key屬性來識別元素

	語法
		列表 (使用map())
			function ..(props) {
		
				let list = props.list.map((value, index) => {
					return (
						//React元素
					);
				});
				
				return (
					...{list}...
				);
			}
			
			或 (直接寫在return裡, 需用大括號包含)
			function ..(props) {
				
				return (
					...
					{props.list.map((value, index) => {
						return (
						//React元素
						);
					}}
					...
				);
			}
	
		Keys
			<標籤 key="值">

	注意	
		無key時 : 列表中若未加key屬性, 則會看到以下警告訊息
			Warning: Each child in an array or iterator should have a unique "key" prop.
			See https://fb.me/react-warning-keys for more information.
				
		唯一性 : key在兄弟節點間必須是唯一 (不需全局唯一), 否則會看到以下警告訊息
			Warning: Encountered two children with the same key, `重複的值`.
			Keys should be unique so that components maintain their identity across updates.
			Non-unique keys may cause children to be duplicated and/or omitted — the behavior is unsupported and could change in a future version.
				
			*註 : 若順序可能改變時, 建議不要用index當key, 否則可能導致渲染變很慢 	
				
		何處指定key : 因為keys只在兄弟節點間有意義, 所以應該在"兄弟標籤"上指定key屬性, ex..
		
				//錯誤的位置								//正確的位置
				<TodoList>									<TodoList>
					<Item>										<Item key="0">		<--
						<li key="0">xxx</li>	<--					<li>xxx</li>
					</Item>										</Item>
					<Item>										<Item key="1">
						<li key="1">xxx</li>						<li>xxx</li>
					</Item>										</Item>
					<Item>										<Item key="2">
						<li key="2">xxx</li>						<li>xxx</li>
					</Item>										</Item>
				</TodoList>									</TodoList>
		
		
		不可讀取 : key是給底層用的, 並不會真的傳給組件, 在組件內使用 props.value 會看到以下警告訊息
			Warning: Item: `key` is not a prop. Trying to access it will result in `undefined` being returned.
			If you need to access the same value within the child component, you should pass it as a different prop. (https://fb.me/react-special-props)
			
			
	範例
		function Item(props) {
			return (
				<li>{props.value}</li>
			);
		}

		function TodoList(props) {
			let list = props.list.map((value, index) => {
				return <Item key={index} value={value} />
			});
			return (
				<ul>{list}</ul>
			);
		}

		const array = ["JavaScript", "jQuery", "Node.js", "AngularJS", "React.js", "Vue.js"];

		ReactDOM.render(
			<TodoList list={array} />,
			document.getElementById("root")
		);
	
	
九. 表單 (checkbox補!!!!!!!!!!!!!!) 

	受控組件(Controlled Component)
		簡述 : 值由React控制的輸入表單組件

		特徵
			1. 值 : 用屬性value控制
			2. 更新值 : 用onChage屬性控制 (通常指向組件class內另handleXyz方法)
			*註 : 以上兩點在組件class內, 都是props底下的特性
			
		範例
			class NameForm extends React.Component {
				constructor(props) {
					super(props);
					this.state = {name : undefined};	//此初始值會被<input>所使用, 設成null會有警告訊息, 設成undefined則不會
					this.handleChange = this.handleChange.bind(this);
					this.handleSubmit = this.handleSubmit.bind(this);
				}
				
				handleChange(event) {
					this.setState({name : event.target.value});
				}
				
				handleSubmit(event) {
					// 提交
					event.preventDefault();
				}
				
				render() {
					return (
						<form onSumit={this.handleSubmit}>
							<label>
								id :&nbsp;
								<input type="text" value={this.state.name} onChange={this.handleChange} />
							</label>
							<input type="submit" />
						</form>
					);
				}
			}

	React的<textarea>
		注意
			文字內容 : React的<textarea>透過屬性value設定 (原生HTML必需寫成 <textarea>xxx</textarea>)
			撰寫方式 : 單標籤
			
		語法
			<textarea value={值} />

		範例
			class TextAreaForm extends React.Component {
				constructor(props) {
				   super(props);
				   this.state = {
					   isFirst : true,
					   text : "list your skills of Java Framework"
				   };
					this.handleClick = this.handleClick.bind(this);
					this.handleChange = this.handleChange.bind(this);
				}

				handleClick(event) {
					if (this.state.isFirst) {
						event.target.value = "";
						this.setState({isFirst : false, text : ""});
					}
				}

				handleChange(event) {
					this.setState({text : event.target.value});
				}

				render() {
					return (
						<div>
							<textarea
								value={this.state.text}
								onClick={this.handleClick}
								onChange={this.handleChange} />
						</div>
					);
				}
			}

	React的<select> - <option>
		注意
			預選 : 使用value屬性, 而不使用原生HTML的selected屬性
			
		語法
			<select value={選取選項}>
				<option value="值1">選項1</option>
				<option value="值2">選項2</option>
				...
				<option value="值N">選項N</option>
			</select>

		範例
			class CityForm extends React.Component {
				constructor(props) {
					super(props);
					this.state = {city : "TPC"};	// 設定預選
					this.handleSubmit = this.handleSubmit.bind(this);
					this.handleChange = this.handleChange.bind(this);
				}

				handleSubmit(event) {
					let xhr = new XMLHttpRequest();
					const url = "http://localhost:8080/SpringHibernateLog4jDemo/memberRest/sendCity";
					xhr.open("POST", url, true);
					xhr.setRequestHeader("Content-Type", "application/json; charset=utf-8");
					xhr.send(JSON.stringify({city : this.state.city}));
					event.preventDefault();
				}

				handleChange(event) {
					this.setState({city : event.target.value});	// 不加此行不能改變選項
				}

				render() {
					return (
						<form onSubmit={this.handleSubmit}>
							<label>
								choose city
								<br />
								<select value={this.state.city} onChange={this.handleChange}>
									<option value="KLC">基隆市</option>
									<option value="TPC">台北市</option>
									<option value="NTPC">新北市</option>
									<option value="TYH">桃園市</option>
									<option value="HCT">新竹市</option>
									<option value="HCH">新竹縣</option>
								</select>
							</label>
							<br />
							<input type="submit" value="Submit" />
						</form>
					);
				}
			}

	React的<input type="file" />
		注意
			唯讀性 : 由於value屬性是唯讀的, 所以在React中屬於非受控組件. (待續..)
	
	多輸入處理
		注意
			設定name屬性, 使用event.target.name來識別
			
		範例 *註 : 此段程式有警告訊息(讓受控組件變成非受控組件), 未解(??)
			class MultiInputsForm extends React.Component {
				constructor(props) {
					super(props);
					this.state = {
						skills : {java : true, javascript : false},
						age : 30
					};
					this.handleInputChange = this.handleInputChange.bind(this);
				}

				handleInputChange(event) {
					let target = event.target;
					if (target.name === "skills") {
						this.setState({skills : {[target.value] : target.checked}});
					} else {
						this.setState({[target.name] : target.value});
					}
				}

				render() {
					return (
						<form>
							<label>
								choose skills
								<br />
								<input type="checkbox"
									   name="skills"
									   value="java"
									   checked={this.state.skills.java}
									   onChange={this.handleInputChange} />
								Java
								&nbsp;
								<input type="checkbox"
									   name="skills"
									   value="javascript"
									   checked={this.state.skills.javascript}
									   onChange={this.handleInputChange} />
								JavaScript
							</label>
							<br />
							<label>
								age
								<input type="number" value={this.state.age} name="age" onChange={this.handleInputChange} />
							</label>
							<br />
							<input type="submit" value="Submit" />
						</form>
					);
				}
			}

	替代方法 : 非受控組件


十. 狀態提升
	簡述 : 將狀態提升至最小的共同父組件內, 以達到兄弟組件間共享狀態
	
	作法 : 將子組件的state轉存至父組件state, 子組件不使用state而使用props

	範例 - 公斤<->磅 計算器 (改其中一單位之值, 另單位之值也會跟著改變)
		
		//子組件 - 輸入框
		class InputForm extends React.Component {
			constructor(props) {
				super(props);
				this.handleChange = this.handleChange.bind(this);
			}

			handleChange(e) {
				this.props.handleChange(e.target);
			}

			render() {
				return (
					<fieldset>
						<legend>{this.props.scale}</legend>		//<--使用props
						<input
							type="number"
							value={this.props.value}
							onChange={this.handleChange}		//<--使用props
							data-scale={this.props.scale} />	//<--使用props
					</fieldset>
				);
			}
		}

		// 父組件 - 計算器(含有兩個子組件)
		class Calculator extends React.Component {
			static TO_LB = 2.20462262;
			static TO_KG = 0.45359237;

			constructor() {
				super();
				this.state = {currScale : undefined, value : 0};		//<--子組件要用之值, 儲存在父組件的state
				this.handleChange = this.handleChange.bind(this);
			}

			handleChange(target) {
				this.setState({currScale : target.dataset.scale, value : target.value});
			}

			render() {
				const currScale = this.state.currScale;
				const value = this.state.value;

				let valueOfKg = currScale === "lb" ? Calculator.TO_KG * value : value;
				let valueOfLb = currScale === "kg" ? Calculator.TO_LB * value : value;

				return (
					<div>
						<InputForm scale="kg" value={valueOfKg} handleChange={this.handleChange} />
						<InputForm scale="lb" value={valueOfLb} handleChange={this.handleChange} />
					</div>
				);
			}
		}
		
	
十一. 組合 vs 繼承
	簡述 : 將組件模組化後, 利用"組合"的方式來重複利用組件
	
	注意
		1. React中使用組合, 而不用繼承
		2. 組建中可接受任何元素, 包括基本型態、函數、React元素
		3. 跟UI無關的程式碼, 應寫在組件外
		
	容器組件 : 其內可用多個內組件
	
		範例1 - 一個內組件, 使用特殊的props.children
			// 容器組件
			function Border(props) {
				return (
					<div style={{border : "solid 1px " + props.color}}>
						{props.children}			//<--因為有此行, 內組件才會被加進來
					</div>
				);
			}
			
			// 使用容器組件的組件
			function Dialog(props) {
				return (
					<Border color="blue">
						<h1>Hi, {props.name}</h1>	//<--對應上{props.children}
					</Border>
				);
			}
			
		範例2 - 多內組件, 自訂props.特性
			// 容器組件
			function Border(props) {
				return (
					<div style={{border : "solid 1px " + props.color}}>
						{props.up}			//<--因為有此行, 內組件才會被加進來
						<hr />
						{props.bottom}		//<--因為有此行, 內組件才會被加進來
					</div>
				);
			}
			
			// 使用容器組件的組件
				*註 : 此處寫成<Border /> "單"標籤
			
			function Dialog(props) {
				return (
					<Border color="red" up={
						<h1>Hi, {props.name}</h1>
					} bottom={
						<p>Welcome to React</p>
					} />
				);
			}
		
	特殊實例(Special Cases) : 由已存在組件延伸出的新組件. 在React中一樣使用"組合"來實踐, 而非繼承
		
		範例 - 由Dialog延伸出的WelcomeDialog
			// Dialog組件
			function Dialog(props) {
				return (
					<Border color="red" up={
						<h1>Hi, {props.name}</h1>
					} bottom={
						<p>{props.msg}</p>
					} />
				);
			}
			
			// WelcomeDialog組件
			function WelcomeDialog(props) {
				return (
					<Dialog name={props.name} msg="Welcome" />
				);
			}


十二. React實作分析
	步驟
		1. UI分析 : 由視覺稿定義出組件的命名、層級架構
		
		2. UI實作(排版) : 實作一個靜態版本

		3. 資料分析 : 分析出動態部分(state)
			考慮3個問題 (符合其中一點就不是state)
				3.1 由父組件傳來否(props)
				3.2 隨時間變化否
				3.3 可以靠其他state或props計算出否

		4. state歸屬分析 : state存放至何組件, 步驟
			4.1 確定需要此state的組件
			4.2 若多個組件需要此state, 找出最小共同父組件
			4.3 最小共同父組件擁有此state, 還是另外更高層組件應該擁有
			4.4 若更高層組件應該擁有此state, 就建立一個組件, 僅用來存此state, 且放至比最小共同父組件更高的層級
			
		5. 資料流分析
			5.1 事件觸發 : 由哪個子組件呼叫哪個父組件
			5.2 更新狀態 : setState()

	範例 - 列表 (含過濾功能)
		需求
			https://doc.react-china.org/static/thinking-in-react-components-eb8bda25806a89ebdc838813bdfa3601-82965.png

		步驟1 - UI分析
			FilterableProductTable (橙色)
				SearchBar (藍色)
				ProductTable (綠色)
					ProductCategoryRow (藍綠色)
					ProductRow (紅色)

		步驟2 - UI實作
			(略)
		
		步驟3 - 資料分析
			state.filterText : 過濾的文字
			state.isStockOnly : 只顯示有庫存否
			
		步驟4 - state歸屬分析
			state存至FilterableProductTable (最外圍容器)
			
		步驟5 - 資料流分析
			5.1 事件由子組件SearchBar觸發, 呼叫父組件FilterableProductTable的對應方法
			5.2 在父組件FilterableProductTable呼叫setSate()分別更新filterText和isStockOnly

		程式碼
			
			// 資料
			const products = [
				{category: "Sporting Goods", price: "$49.99", stocked: true, name: "Football"},
				{category: "Sporting Goods", price: "$9.99", stocked: true, name: "Baseball"},
				{category: "Sporting Goods", price: "$29.99", stocked: false, name: "Basketball"},
				{category: "Electronics", price: "$99.99", stocked: true, name: "iPod Touch"},
				{category: "Electronics", price: "$399.99", stocked: false, name: "iPhone 5"},
				{category: "Electronics", price: "$199.99", stocked: true, name: "Nexus 7"}
			];
			
			// 搜尋列組件
			class SearchBar extends React.Component {
				constructor(props) {
					super(props);
					this.handleFilter = this.handleFilter.bind(this);
					this.handleChecked = this.handleChecked.bind(this);
				}

				handleFilter(e) {
					this.props.handleFilter(e.target.value);
				}

				handleChecked(e) {
					this.props.handleChecked(e.target.checked);
				}

				render() {
					return (
						<div>
							<input type="text" placeholder="Search..." onChange={this.handleFilter}/>
							<br/>
							<input type="checkbox" onChange={this.handleChecked}/>
							Only show products in stock
						</div>
					);
				}
			}
			
			// 產品分類列組件
			function ProductCategoryRow(props) {
				return (
					<tr>
						<th colSpan="2">{props.category}</th>
					</tr>
				);
			}
			
			// 產品列組件
			function ProductRow(props) {
				let product = props.product;
				let name = product.stocked ? product.name : <span style={{color: "red"}}>{product.name}</span>
				return (
					<tr>
						<td>{name}</td>
						<td>{product.price}</td>
					</tr>
				);
			}
			
			// 產品列表組件
			function ProductTable(props) {
				let currCategory;
				let rows = [];
				products.forEach(product => {
					if (product.name.indexOf(props.filterText) === -1
						|| (props.isStockOnly && !product.stocked))
						return;

					let category = product["category"];
					if (currCategory !== category) {
						rows.push(<ProductCategoryRow category={product["category"]} key={product.category}/>);
						currCategory = category;
					}
					rows.push(<ProductRow product={product} key={product.name}/>)
				});
				return (
					<table>
						<thead>
						<tr>
							<th>Name</th>
							<th>Price</th>
						</tr>
						</thead>
						<tbody>
						{rows}
						</tbody>
					</table>
				);
			}
			
			// 整個組件
			class FilterableProductTable extends React.Component {
				constructor(props) {
					super(props);
					this.state = {filterText: "", isStockOnly: false};
					this.handleFilter = this.handleFilter.bind(this);
					this.handleChecked = this.handleChecked.bind(this);
				}

				handleFilter(value) {
					this.setState({filterText: value})
				}

				handleChecked(checked) {
					this.setState({isStockOnly: checked})
				}

				render() {
					return (
						<div>
							<SearchBar handleFilter={this.handleFilter} handleChecked={this.handleChecked}/>
							<ProductTable filterText={this.state.filterText} isStockOnly={this.state.isStockOnly}/>
						</div>
					);
				}
			}


===========================================================================================================================
進階

深入JSX
	React元素的型態
		必需引入
			1. 只是React.createElement()語法糖
			
			2. <Xyz>會被編譯成同名的變數並被使用, 所以使用前必需先聲明. ex..
				SearchBar.js
					class SearchBar extends React.Component {
						...
					}
					
					export default SearchBar;				<--匯出
					
				Main.js
					import SearchBar from "./SearchBar";	<--引入
				
					ReactDOM.render(
						<SearchBar />,
						document,getElementById("root")
					);

				*註 : 如果使用<script>載入, 作用範圍是全局

		點表示法
			1. 定義時, React組件也可以巢狀包含, 形成內部React組件, ex..
				const MyComponents = {
					DatePicker: function DatePicker(props) {							<--定義內部組件
						return <div>Imagine a {props.color} datepicker here.</div>;
					}
				}
			2. 使用時, 使用點表示法, ex..
				function BlueDatePicker() {
					return <MyComponents.DatePicker color="blue" />;					<--使用點表示法
				}
			
		大寫開頭
			1. 小寫開頭為HTML原生標籤, ex. div、span
			2. 大小開頭為React組件, <Foo />會編譯為React.createElement(Foo)
			
		執行時期選擇React組件
			JSX角括弧中不能使用js的表達式(expression), 若要在執行時期動態選擇React元素, 需先指定給一大寫開頭的變數ex..
				function User1() {
					...
				}
				
				function User2() {
					...
				}
				
				const users = [User1, User2];
				let input = prompt();
				const User = users[input % 2];	<--一定要用大寫開頭的變數名
				
				ReactDOM.render(
					<User />,
					root
				);
			
	屬性指定方式
		方式1 - JavaScript表達式
			語法
				<元素 屬性={expression} />
				
			範例
				<Component name={1 + 2 + 3} />
		
		方式2 - 字串字面常數
			語法
				<元素 屬性="字串字面常數" />
			
			範例
				<Component name="william" />
				
			*註 : 會直接用HTML方式解析, ex..
				<Component name="&lt;3" />
				等同
				<Component name={"<3"} />
				
		方式3 - 不指定值
			說明 : 因預設值為true, 所以不只值的狀況下等同指定為true
		
			語法
				<元素 屬性 />
				
			範例
				<Component name />
				等同
				<Component name={true} />
				
		方式4 - 擴展	
			說明 : 傳遞屬性物件. 會自動用 屬性物件特性名 映射 屬性名
			
			語法
				<元素 {...屬性物件名}
		
			範例
				function User(props) {
					return (
						<div>name : {props.name}, age : {props.age}, birthday : {props.birthday}</div>
					);
				}
			
				const p1 = {name : "william", age : 30, birthday : new Date(1988, 0, 17).toDateString()};
		
				<User {...p1} />
		
	子元素指定方式 (props.children)
		方式1 - 字串字面常數
			語法
				<父元素>字串字面常數</父元素>
				
			*註 : JSX會"自動"去除頭尾的空白、Tab、換行; 字串字面常數中含有的換行則會被轉成一個空白
		
			範例 (以下四種寫法都是一樣的結果)
				<Welcome>Welcome to React</Welcome>
				
				// 去除頭尾的空白
				<Welcome>   Welcome to React   </Welcome>
				
				// 去除頭尾換行和Tab
				<Welcome>
					Welcome to React
				</Welcome>
				
				// 字串字面常數中的換行被轉成空白
				<Welcome>Welcome
				to
				React</Welcome>
				
		方式2 - JSX
			語法
				<父元素>
					<子元素1>
					<子元素2>
				</父元素>
				
			方式2.1 - 元素陣列
				語法
					[
						<元素1 />,
						<元素2 />,
						...,
						<元素N />
					];
					
				範例
					return [
						<li key="a">One</li>,
						<li key="b">Two</li>,
						<li key="c">Three</li>
					];
				
				
		方式3 - JavaScript表達式		
			語法
				<父元素>{expression}</父元素>
				
			範例
				<ul>
					{skillArr.map(v => {	//skillArr為一字串陣列
						<Item name={v} />
					})}
				</ul>
				
		方式4 - 函數
			說明 : 透過props.children傳遞function型態之參數
			
			語法
				<父元素>{函數名}</父元素>
				
			範例
				function UserList() {
					return (
						<User>
							{() => {
								return {name : "William", age : 30};	<--傳給子元素的
							}}
						</User>
					);
				}
				
				function User(props) {
					let o = props.children();	<--從父元素接收的function, 馬上呼叫拿到物件
					return (
						<li>name : {o.name}, age : {o.age}</li>
					);
				}
				
		方式5 - boolean、null、undefined
			說明 : boolean(false、true)、null和undefined不會被React渲染, 若要被渲染需用String()包含
				
			語法
				<父元素>{String(值)}</父元素>
				
			應用 - 當作判斷條件
				*註 : falsy家族的數字0可當作判斷條件, 但"會"被渲染, 加上Boolean()可避免
			
				範例
					// 假設showHeader是決定<Header>顯示否的變數
					<div>
						{Boolean(showHeader) && <Header />}
					</div>
					
				
使用prop-types進行型態檢查
	*註 : React v15.5前使用的是React.PropTypes. 因為重點用於開發階段, 所以v15.5後獨立另一套件
	
	簡述 : npm上的套件, 用以在執行時期檢查props, 但僅用console.warn()發出警告
		
	安裝
		npm install --save prop-types
	
	引入
		import PropTypes from 'prop-types'; // ES6
		var PropTypes = require('prop-types'); // ES5 with npm
		
	cdn (可自行修改版本)
		unpkg
			<!-- development version -->
			<script src="https://unpkg.com/prop-types@15.6/prop-types.js"></script>
			 
			<!-- production version -->
			<script src="https://unpkg.com/prop-types@15.6/prop-types.min.js"></script>
		cdnjs
			<!-- development version -->
			<script src="https://cdnjs.cloudflare.com/ajax/libs/prop-types/15.6.0/prop-types.js"></script>
			 
			<!-- production version -->
			<script src="https://cdnjs.cloudflare.com/ajax/libs/prop-types/15.6.0/prop-types.min.js"></script>
		
	語法
		組件名.propTypes = {
			特性名1 : PropTypes.檢查項目,
			特性名2 : PropTypes.檢查項目,
			...
			特性名N : PropTypes.檢查項目
		}

	檢查種類
		1. props的型態
		2. props的值
		3. props必需否
		
	檢查型態 (PropTypes.)
		JavaScript型態
			PropTypes.bool
			PropTypes.number
			PropTypes.string
			PropTypes.symbol
			PropTypes.array
			PropTypes.func
			PropTypes.object

		複合型態
			任何可被渲染的型態 (number、string、element、array、fragment)
				PropTypes.node

		React型態
			React element
				PropTypes.element

		自訂型態
			PropTypes.instanceOf(型態)

		子型態
			陣列元素型態 (含有一個以上)
				PropTypes.arrayOf(PropTypes.型態)

			物件特性型態 (含有一個以上)
				PropTypes.objectOf(PropTypes.型態)

			物件特性型態 (列舉)
				PropTypes.shape({
					特性1 : PropTypes.型態, 
					特性2 : PropTypes.型態, 
					...
					特性N : PropTypes.型態 
				})

		進階
			任何
				PropTypes.any

			列舉單選
				PropTypes.oneOf([型態1, 型態2, ..., 型態N])
				*註 : 參數可以是上述任何一個

				範例
					PropTypes.oneOfType([PropTypes.bool, PropTypes.instanceOf(Person)])

	檢查值
		PropTypes.oneOf([值1, 值2, ..., 值N])

	必需否
		PropTypes.型態.isRequired
			
	自訂驗證器
		注意
			1. 不符合時需return Error物件
			2. 不可用console.warn()和throw
			3. 不可用在PropTypes.oneOfType()

		一般驗證器

				function(props, propName, componentName) {
					if (!/matchme/.test(props[propName])) {
						return new Error('Invalid prop `' + propName + '` supplied to' + 
							' `' + componentName + '`. Validation failed.');
		    		}
				}
		
		arrayOf()用的驗證器

			function(propValue, key, componentName, location, propFullName) {
				if (!/matchme/.test(props[propName])) {
						return new Error('Invalid prop `' + propName + '` supplied to' + 
							' `' + componentName + '`. Validation failed.');
		    		}
			}

	單獨使用驗證(非用在React)
		語法
			PropTypes.checkPropTypes(檢查項目物件, 被檢查物件, "被檢查物件名", "組件名")
			*註 : "被檢查物件名" 跟 "組件名" 僅用在警告訊息顯示

		範例
			const myPropTypes = {
				name: PropTypes.string,
				age: PropTypes.number,
				// ...
			};

			const props = {
				name: 'hello', // is valid
  				age: 'world', // not valid
			};
		
			PropTypes.checkPropTypes(myPropTypes, props, 'props', 'Component1');
		
		
靜態型別檢查
	簡述 : 在編譯時期檢查型態. 許多此類框架都有自動完成功能, 所以很多人用來取代PropTypes		
		
	Flow
		說明 : JavaScript型態檢查器, 使用@Annotation, 經常跟React一起用
		*註 : Flow 本身就理解 JSX

		步驟
			1. 安裝
				Yarn
					yarn add --dev flow-bin

				npm
					npm install --save-dev flow-bin
		
			2. 將Flow加入專案 : 修改package.json
				{
					// ...
					"scripts": {
						"flow": "flow",
							// ...
					},
					// ...
				}

			3. 初始化(第一次)
				Yarn
					yarn run flow init

				npm
					npm run flow init

			4. 剝離Flow語法
				*註 : create-react-app : 預設已剝離

				npm install --save-dev babel-preset-flow
				npm install --global flow-remove-types
				npm install flow-remove-types

			5. 指定檢查檔案 : 在欲檢查程式檔頂部加上
				// @flow
		
			6. 執行
				Yarn
					yarn flow

				npm
					npm run flow
					*檢查全部檔案加上 --all

			7. 看訊息
			
	TypeScript
		說明 : JavaScript的延伸語言, 有自己的編譯器, 可在編譯時期發現錯誤

		步驟
			1. 安裝
				Yarn
					yarn add -dev typescript

				npm
					npm install --save-dev typescript
		
			2. 將Flow加入專案 : 修改package.json
				{
  					// ...
					"scripts": {
						"build": "tsc",
						// ...
					},
  					// ...
				}

				*註
					1. ref : https://github.com/Microsoft/TypeScript-React-Starter/blob/master/tsconfig.json
					2. 通常會把此檔案加至.gitignore
		
			3. 生成TypeScript組態檔 : tsconfig.json
				tsc --init
		
			4. 設定程式碼來源和目標 : 修改tsconfig.json
				{
					"compilerOptions": {
						// ...
						"rootDir": "src",
						"outDir": "build"
    					// ...
  					},
				}
		
			5. 執行
				Yarn
					yarn build

				npm
					npm run build

			6. 看訊息
				若沒訊息代表成功
		
		進階
			同時顯示來自其他框架的錯誤
				取得聲明文件
					Yarn
						yarn add --dev @types/react
			
					npm
						npm i --save-dev @types/react
		
				局部聲明
					1. 在src下建立declarations.d.ts
					2. 撰寫declarations.d.ts, ex..

						declare module 'querystring' {
							export function stringify(val: object): string
							export function parse(val: string): object
						}

			和 Create React App 一起使用 TypeScript
				create-react-app my-app --scripts-version=react-scripts-ts

	Others
		Reason

		Kotlin : React bindings、Create React Kotlin App

		F#/Fable : elmish-react


Refs & DOM
	簡述 : ref用以儲存在render()中建立的某個節點(HTML節點或React元素)

	*註 : 盡量避免使用ref 

	使用時機
		組件想操作自己包含的其中一個節點

	應用
		1. 處理焦點、選擇文字和媒體控制
		2. 觸發強制動畫
		3. 整合其他框架

	方式
		1. 一般式
		2. 函數式 (callback)

	一般式
		語法
			建立ref (在建構子裡)
				this.特性名 = React.createRef()

			指定節點
				<元素名 ref={this.特性名} />		// 特性名是 建立ref步驟 所指定

			取得節點
				this.特性名.current

			*註 : 組件用函數寫法不可用一般式

		底層動作
			在組件掛載(componentDidMount())時將結點傳入this.特性名.current, 卸載(componentDidUpdate())時再將此特性改為null

		範例一 - (操作自己的節點) click按鈕, 文字輸入框獲得焦點

			class InputForm extends React.Component {
			    constructor() {
			        super();
			        this.ref = React.createRef();	// 建立ref
			        this.handleClick = this.handleClick.bind(this);
			    }

			    handleClick() {
			        this.ref.current.focus();	// 取得節點, 並呼叫focus()
			    }

			    render() {
			        return (
			            <div>
			                <input type="text" ref={this.ref} />	// 指定節點
			                <input type="button" value="submit" onClick={this.handleClick} />
			            </div>
			        );
			    }
			}

		範例二 - (透過ref操作子節點) 父組件含有三個子組件, 掛載時自動讓第一個子組件獲得焦點

			// Child組件同範例一的InputForm組件
			class Child extends React.Component {
			    constructor() {
			        super();
			        this.ref = React.createRef();	// 建立子組件ref
			        this.handleClick = this.handleClick.bind(this);
			    }

			    handleClick() {
			        this.ref.current.focus();	// 取得節點, 並呼叫focus()
			    }

			    render() {
			        return (
			            <div>
			                <input type="text" ref={this.ref} />	// 指定節點
			                <input type="button" value="submit" onClick={this.handleClick} />
			            </div>
			        );
			    }
			}

			class FocusInputForm extends React.Component {
			    constructor(props) {
			        super(props);
			        this.ref = React.createRef();	// 建立父組件ref
			    }

			    componentDidMount() {
			        this.ref.current.handleClick();		// this.ref.current會取得第一個<Child>, 呼叫它的handleClick()
			    }

			    render() {
			        return (
			            <div>
			                <Child ref={this.ref} />	// 指定節點 (第一個子組件)
			                <Child />
			                <Child />
			            </div>
			        );
			    }
			}

	函數式 (callback)
		語法
			建立ref
				constructor() {
					super();

					this.變數名 = null; 		// 宣告一變數, 用以儲存ref之值
					this.特性名 = 方法名;		// 指定callback方法
					this.方法名 = this.方法名.bind(this);	
				}

				方法名(element) {			// 定義callback方法
					this.變數名 = element;	// 將節點儲存起來
				}

			指定節點
				<元素名 ref={this.特性名} />		// 特性名是 建立ref步驟 所指定

			取得節點
				this.變數名

		底層動作
			在組件掛載(componentDidMount())時將結點傳入callback函數, 卸載(componentDidUpdate())時會再將null傳入callback函數

			*註
				問題 : 在更新期間callback函數會被呼叫"兩次", 第一次會傳入null. 第二是才是節點
				解法 : 將callback函數定義在類別裡, 且用bind()綁定

		範例
			class InputForm extends React.Component {
			    constructor() {
			        super();
			        this.ref = null;				// 宣告一變數, 用以儲存ref之值
			        this.setRef = this.setRef;		// 指定callback方法
			        this.setRef = this.setRef.bind(this);
			        this.handleClick = this.handleClick.bind(this);
			    }

			    setRef(element) {					// 定義callback方法
			        this.ref = element;				// 將節點儲存起來
			    }

			    handleClick() {
			        this.ref.focus();				// 取得節點, 並呼叫focus() 
			    }

			    render() {
			        return (
			            <div>
			                <input type="text" ref={this.setRef} />		// 指定節點
			                <input type="button" value="submit" onClick={this.handleClick} />
			            </div>
			        );
			    }
			}

	函數組件使用ref
		說明 : 函數組件因為沒有ref的實例, 所以不能用一般式, 但可用函數式(callback)

		語法
			function 組件名(props) {

				let ref;	// 宣告一變數, 用以儲存ref之值

				return (
					...
					<元素 ref={element => {		// 使用函數式(callback)
						ref = element;			// 將節點儲存起來
						...
					}} />
					...
				);
			}

		範例
			function CustomTextInput(props) {
			    let ref;	// 宣告一變數, 用以儲存ref之值

			    function handleClick() {
			        ref.focus();		// 呼叫節點的focus()
			    }

			    return (
			        <div>
			            <input type="text" ref={(input) => {	// 使用函數式(callback)
			                ref = input;						// 將節點儲存起來
			            }} />

			            <input type="button" value="GetFocus" onClick={handleClick} />
			        </div>
			    );
			}


非受控組件
	







===========================================================================================================================
Arrow Function(箭頭函數)
	注意
		1. 沒有this、arguments、super、new.target
		2. 適用於匿名時
		3. 不能用在建構子
		4. 
		
	語法
		(參數1, 參數2, ..., 參數N) => {...}
		
		//本體只有一行時, 可省略{}, 那一行也自動會加上return
		(參數1, 參數2, ..., 參數N) => ...
		
		//只有一個參數時, 可省略()
		參數1 => {...}
		
		//但沒有參數時, 不可省略()
		() => {...}


雜
	1. ES6(arrow function、class、let、const)
	2. React元素就是一個js物件
	3. 在使用JavaScript classes時，你必須調用 super();方法才能在繼承父類的子類中正確獲取到類型的this
	4. JSX 元素的最外層套上了一小括號，以防止JavaScript 代碼在解析時自動在換行處添加分號
	5. 不可变性
		5.1 實現撤銷/重做以及時間旅行
		5.2 記錄變化
		5.3 React 當中判定何時重新渲染
	6. key	
		6.1 渲染列表項時，React 都會試著存儲對應每個單獨項的相關信息，如果你的組件包含state 狀態數據，那麼這些狀態數據必須被排序
		6.2 React 必須能夠知道是那一項改變了
		6.3 key是React當中使用的一種特殊的屬性（除此之外還有ref屬性），React會將元素的key值和對應元素綁定存儲起來。無法通過this.props.key獲取到key的值
		6.4 假如你不提供任何key值，React會提示警告，並且默認使用數組的索引作為默認的key 
		6.5 只需要在當前的節點裡保證唯一即可
	
	7. Property initializer syntax
	8. Computed property names (可計算屬性名)
	9. Shorthand初始化
		https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer#New_notations_in_ECMAScript_2015
	10. function* () {yield}
	11. import React, {Component} from "react";
	12
		npx create-react-app 專案名
		cd 專案名
		npm start


class
	*註
		1. 此類別為React組件類別
		2. render()回傳React元素, 是想要渲染的內容描述

	class 類別名 extends React.Component {
		...
	
		render() {
			...
			return (...);
		}
	}
	
	render內容
		一般js寫法
			render() {
				return React.createElement('根標籤', {屬性1 : '值1'},
					React.createElement('子標籤1, {子子標籤...}),
					React.createElement('子標籤2, {子子標籤...}),
					...
					React.createElement('子標籤N, {子子標籤...})
				);
			}
			
		JSX寫法
			render() {
				//HTML語法
			}

函數定義組件(functional components)
	說明 : 若React組件類別內只有render(), 就可以使用較簡潔的函數定義組件寫法
	
	語法
		function 組件名(props) {
			return (
				//JSX
			);
		}
		
		*註 : this.props需換成props


Chrome React Tool
	https://reactjs.org/react-devtools-state-ef94afc3447d75cdc245c77efb0d63be.gif








			