一. Hello World
	IDE
		1. codepen : https://codepen.io/gaearon/pen/ZpvBNJ
		2. Babel REPL : http://babeljs.io/repl/
		3. local
		
	cdn
		React
			https://reactjs.org/docs/cdn-links.html有說明
			*註 : 開發版才有完整的錯誤訊息

		Babel(JSX編譯器)
			<script src="https://unpkg.com/@babel/standalone/babel.js"></script>
		
	注意事項 : 常用ES6(arrow function、class、let、const)
	
	名詞
		React元素 : React中的最小單位, 程式面來看是普通物件
		組件 : 由React元素組成, 程式面來看是純函數或類別
		<HTML元素> --> <React元素> --> 組件

		*註 : React元素為組件的回傳值
		
	簡單範例 (without JSX、npm)
		index.html
			<!DOCTYPE html>
			<html lang="en">
			<head>
				<meta charset="UTF-8">
				<title>Index</title>
				<script crossorigin src="https://unpkg.com/react@16/umd/react.development.js"></script>
				<script crossorigin src="https://unpkg.com/react-dom@16/umd/react-dom.development.js"></script>
			</head>
			<body>
				<div id="root"></div>
			</body>
			</html>
			<script src="index.js"></script>
		
		
		index.js
			function Welcome(props) {
				return React.createElement(
					"div",
					null,
					`hi, ${props.name}`
				);
			}

			ReactDOM.render(
				Welcome({name : "william"}),
				document.getElementById("root")
			);


二. JSX
	簡述 : JavaScript 的語法擴展, 用來聲明React當中的元素. 在編譯之後呢, JSX 其實會被轉化為普通的JavaScript表達式
	
	注意事項
		1. HTML的單標籤轉成JSX都需加上斜線, ex. <br />、<input type="submit" />
		2. 整個JSX : 放在小括號裡, 以防止分號自動插入的bug
			ex.
				const element = (<div>hi, </div>);
				
		3. JavaScript表達式 : 在JSX中使用時, 需包含在大括號裡
			ex.
				const element = (<div>hi, {p1.name}</div>);

		4. 屬性值
			4.1 字串型態 : "值"
				ex.
					const element = (<div value="abc">...</div>);

			4.2 其他型態 : {JavaScript表達式}
				ex.
					const element = (<div value={p1.name}>...</div>);

		5. 屬性命名 : 小駝峰
		
		6. 防止XSS : 所以要呈現的東西, 在渲染前都會轉成字串

		7. 編譯時期的底層動作
			7.1 Babel轉譯器會把JSX轉換成一個名為React.createElement()的方法呼叫
				ex.
					const element = (<div value="abc">hi</div>);
					等同
					const element = React.createElement("div", {value : "abc"}, "hi");

			7.2 React.createElement()會進行一些避免bug的檢查, 並回傳一個物件
				ex. 
					{
						type : "div",
						props : {
							value : "abc",
							children : "hi"
						}
					}


三. 元素渲染
	簡述 : React元素是構成React應用的最小單位, 即描述你在屏幕上看到的內容.
		   事實上是普通的物件, React DOM 可以確保瀏覽器DOM 的數據內容與React 元素保持一致

	*註
		1. React元素在此皆簡稱為元素
		2. "元素"跟"組件"是不同的東西, 組件是由元素所組成
	
	注意事項
		1. 根元素 : ex. <div id="root"></div>, 將由React DOM 來管理. 一般只會定義一個根節點
		
		2. 渲染 : 透過ReactDOM.render(元素, 根元素)
		
		3. immutable不可變的 : 元素被創建之後, 你是無法改變其內容或屬性, 它代表應用界面在某一時間點的樣子

		4. 可配合setInterval()等函數使用
			ex.
				function showDate() {
					function Test() {
						const elt1 = (<div>{new Date().toLocaleTimeString()}</div>)
						return elt1;
					}

					ReactDOM.render(<Test />, document.getElementById("root"));
				}

				setInterval(showDate, 1000);

			*註 : 多數React應用只會調用一次ReactDOM.render()
		
		5. 局部更新 : React DOM 首先會比較元素內容先後的不同, 而在渲染過程中只會更新改變了的部分


四. 組件& Props
	簡述 : 從UI的觀念來看, 組件是將UI切分成一些的獨立的、可複用的部件; 從程式面來看它是一個函數, 可接收參數(props), 並回傳React元素

	定義
		*註
			1. 組件名以大寫開頭
			2. 兩種方式的回傳React元素 都可以配合 JSX 或 React.createElement() 來使用
			3. 當React遇到元素是自定義的組件, 他會將其內的屬性紀錄在props特性
	
		方式1 - 函數式
			語法
				function 組件名(props) {
					...
					return React元素;
				}

			範例
				// with JSX
				function Square(props) {
					return (
						<button className="square" onClick={props.onClick}>
							Submit
						</button>
					);
				}
				
				// with React.createElement()
				function Square(props) {
					return React.createElement(
						"button",
						{className : "elt1", onClick : props.onClick},
						"Submit"
					)	
				}
					
		方式2 - 類別式
			語法
				class 組件名 extends React.Component {
					render() {
						return React元素;
					}
				}

			範例
				// with JSX
				class Square extends React.Component {
					render() {
						return (
							<button className="square" onClick={props.onClick}>
								Submit
							</button>
						);
					}
				}

				// with React.createElement()
				class Square extends React.Component {
					render() {
						return React.createElement(
							"button",
							{className : "elt1", onClick : props.onClick},
							"Submit"
						)
					}
				}

	Props初始值
		語法
			*註 : 函數式與類別式相同

			組件名.defaultProps = {
				特性名1 : 特性值1,
				特性名2 : 特性值2,
				...,
				特性名N : 特性值N
			};


	組合組件
		簡述 : 組件可巢狀包含, 形成新的組件

		*註 : 通常一個React程式頂端會是一個App組件

		範例
			function Square(props) {
				return (
					<button className="square" onClick={props.onClick}>
						{props.text}
					</button>
				);
			}

			function App(props) {
				return (
					<div>
						<Square text={props.text[0]} />
						<Square text={props.text[1]} />
						<Square text={props.text[0]} />
					</div>
				);
			}

			ReactDOM.render(
				<App name={["Submit", "Confirm", "Cancel"]} />,
				document.getElementById("root")
			);

	Props的不可變性 : 同純函數特性
		
			
五. State & 生命週期
	state特點
		1. state跟props很像
		2. state是私有的, 只在當前組件; props則是由別處傳來
		3. 只限用在class定義方式
		4. 在類別中用 this.state 存取
		5. 不用在render()中的東西, 就不應該儲存在state
		6. 非建構子中更新state : 使用this.setState()
			6.1 跟props無關 : this.setState(狀態物件)
				ex.
					this.setState({date : new Date()});
					
			6.2 跟props有關 : this.setState((原狀態, props) => {})
				*註 : 因為狀態更新可能是在非同步的狀況下, 所以需用"函數"
				ex.
					this.setState((prevState, props) => {
						counter: prevState.counter + props.step;
					});
					
			*註 : this.setState()會"單獨更新"有指定到的部分, 意義上比較像"updateState"
	
		7. 外部無法知道是否有state
	
	生命週期特點
		1. 建構子 : construtor(), 在被實例化時執行, 唯一能初始化的地方
		2. 掛載方法 : componentDidMount(), 在第一次被加入UI時執行
		3. 卸載方法 : componentWillUnmount(), 在從UI中移除時執行
		4. 2跟3兩方法被稱為lifecycle hooks(鉤)
			
			
	範例
		class Clock extends React.Component {
		
			// 建構子
			constructor(props) {
				super(props);
				this.state = {date : new Date()};	// 初始化state
			}
			
			// 掛載方法
			componentDidMount() {
				this.timerId = setInterval(
					() => {this.setState({date : new Date()});},	// 更新state
					1000
				);
			}
  
			// 卸載方法
			componentWillUnmount() {
				clearInterval(this.timerId);
			}
  
			render() {
				return (
					<div>{this.state.date.toTimeString()}</div>
				);
			}
		}
			
			
六. 事件處理
	注意
		1. 寫法 : 與HTML DOM事件處理很相似
		2. 命名 : 屬性命名使用小駝峰式
		3. 註冊 : 使用JSX時, 指定代表函數的變數名, 非字串
			ex.
				<button onClick="{processor}">Submit</button>
			
		4. 取消預設行為 : 需用e.preventDefault(), 不可用return false
		5. React的事件物件 : 事件處理器的參數, 是一個合成事件(SyntheticEvent), 已含跨瀏覽器兼容性
			
	建立步驟
		0. 建立一類別
		
		1. 定義處理器 : 在類別裡定義一函式
		
		2. 把this注入處理器
			*註 : 類別的方法預設不會注入this, 需手動把this注入進去
		
			方式1 - 使用 bind() (in constructor)
				class 類別名 extends React.Component {
			
					constructor() {
						...
						this.處理器名 = this.處理器名.bind(this);	// <--
					}
					
					處理器名() {
						...
					}
					
					...
				}
			
			方式2 - 使用 屬性初始化器(Property initializer)
				*註 : 
					1. 其實就是方法的定義使用箭頭函數
					2. 此語法還屬於實驗階段
					3. 若使用create-react-app會自動開啟此語法支援
				
				class 類別名 extends React.Component {
			
					處理器名 = () => {
						...
					}
					
					...
				}
				
			方式3 - 多包一層函數 (在註冊時)
				*註 : 此種方式每次渲染時都會新建一個callback函數, 效能較低
			
				<標籤 事件屬性={(e) => this.處理器名(e)} >
				
				ex.
					<button onClick={(e) => this.handleClick(e)}>	// 假設已先定義handleClick()
			
		3. 註冊
		
	範例
		class Toggle extends React.Component {
			constructor(props) {
				super(props);
				this.state = {isToggleOn : true};
				
				// 步驟2 : bind()
				this.handleClick = this.handleClick.bind(this);
			}
			
			// 步驟1 : 定義
			handleClick(e) {
				this.setState((prevState) => {
					{isToggleOn: !prevState.isToggleOn};
				});
			
			}
			
			render() {
				return (
					// 步驟3 : 註冊
					<button onClick={this.handleClick}>
						{this.state.isToggleOn ? "ON" : "OFF"}
					</button>
				);
			}
		}
		
	事件處理器的參數
		預設參數 : 不需指定, 自動會被傳遞
			e : React事件物件
			
			範例
				<button onClick={this.deleteAll}>Submit</button>
				
				deleteAll(e) {
					...
				}
		
		額外參數
			方式1 -  多包一層函數 (在註冊時)
				*註 : e的順序自訂, 只需傳送跟接收兩端配合
				
				語法
					傳送
						<標籤 事件屬性={(e) => this.處理器名(額外參數1, 額外參數2, ..., 額外參數N, e)} >
						
					接收
						處理器名(額外參數1, 額外參數2, ..., 額外參數N, e)
						
				範例
					<button onClick={(e) => this.deleteById(id, e)}>Submit</button>
					
					deleteById(id, e) {
						...
					}
		
			方式2 - 使用 bind() (在註冊時)
				*註 : e會"自動"被加在"最後"一個參數
				
				語法
					傳送
						<標籤 事件屬性={this.處理器名.bind(this, 額外參數1, 額外參數2, ..., 額外參數N)} >
						
					接收
						處理器名(額外參數1, 額外參數2, ..., 額外參數N, e) {
							...
						}
					
				範例
					<button onClick={this.deleteById.bind(this, id)}>Submit</button>

					deleteById(id, e) {
						...
					}


七. 條件渲染
	簡述 : 根據狀態局部渲染

	常用指令
		if
		&&
		三元運算子

	範例 - if
		function GuestGreeting() {
			return (
				<h1>Please sign up</h1>
			);
		}

		function UserGreeting(props) {
			return (
				<h1>Welcome back, {props.name}</h1>
			);
		}

		function Greeting(props) {
			const isLoggedIn = props.isLoggedIn;

			if (isLoggedIn) {
				return <UserGreeting name={props.name}/>;
			}
			return <GuestGreeting />;
		}

		ReactDOM.render(
			<Greeting isLoggedIn={true} name="william" />,
			root
		);

	範例 - &&
		function Mailbox(props) {
			const unreadMsg = props.unreadMsg;

			return (
				<div>
					Hey {props.name}
					{unreadMsg.length > 0 &&
						<h2>You have {unreadMsg.length} unread Message.</h2>}
				</div>
			);
		}

		const msg = ["C", "C++", "C#", "Java", "ASP", "SQL", "Android", "JavaScript", "Scala"];

		ReactDOM.render(
			<Mailbox name="william" unreadMsg={msg} />,
			root
		);
	
	範例 - 三元運算子
		function GuestGreeting() {
			return (
				<h1>Please sign up</h1>
			);
		}

		function UserGreeting(props) {
			return (
				<h1>Welcome back, {props.name}</h1>
			);
		}

		function Greeting(props) {
			const isLoggedIn = props.isLoggedIn;

			return isLoggedIn ? <UserGreeting name={props.name}/> : <GuestGreeting />;
			 
		}

		ReactDOM.render(
			<Greeting isLoggedIn={true} name="william" />,
			root
		);
	
	
	阻止渲染
		簡述 : 某些狀況下會需要"隱藏"組件
	
		方式 : render()回傳null
		
		注意 : 並不會影響組件的生命週期方法的回呼 (ex. componentWillUpdate()、componentDidUpdate() ..)
			
		範例
			function User(props) {
				if (!props.isLoggedIn) {
					return null;
				}
				return (
					<div>{props.name}</div>
				);
			}
	
	
八. 列表 & Keys

	用途 : React底層在增加或刪除元素時, 比對演算法需要key屬性來識別元素

	語法
		列表 (使用map())
			function ..(props) {
		
				let list = props.list.map((value, index) => {
					return (
						//React元素
					);
				});
				
				return (
					...{list}...
				);
			}
			
			或 (直接寫在return裡, 需用大括號包含)
			function ..(props) {
				
				return (
					...
					{props.list.map((value, index) => {
						return (
						//React元素
						);
					}}
					...
				);
			}
	
		Keys
			<標籤 key="值">

	注意	
		無key時 : 列表中若未加key屬性, 則會看到以下警告訊息
			Warning: Each child in an array or iterator should have a unique "key" prop.
			See https://fb.me/react-warning-keys for more information.
				
		唯一性 : key在兄弟節點間必須是唯一 (不需全局唯一), 否則會看到以下警告訊息
			Warning: Encountered two children with the same key, `重複的值`.
			Keys should be unique so that components maintain their identity across updates.
			Non-unique keys may cause children to be duplicated and/or omitted — the behavior is unsupported and could change in a future version.
				
			*註 : 若順序可能改變時, 建議不要用index當key, 否則可能導致渲染變很慢 	
				
		何處指定key : 因為keys只在兄弟節點間有意義, 所以應該在"兄弟標籤"上指定key屬性, ex..
		
				//錯誤的位置								//正確的位置
				<TodoList>									<TodoList>
					<Item>										<Item key="0">		<--
						<li key="0">xxx</li>	<--					<li>xxx</li>
					</Item>										</Item>
					<Item>										<Item key="1">
						<li key="1">xxx</li>						<li>xxx</li>
					</Item>										</Item>
					<Item>										<Item key="2">
						<li key="2">xxx</li>						<li>xxx</li>
					</Item>										</Item>
				</TodoList>									</TodoList>
		
		
		不可讀取 : key是給底層用的, 並不會真的傳給組件, 在組件內使用 props.value 會看到以下警告訊息
			Warning: Item: `key` is not a prop. Trying to access it will result in `undefined` being returned.
			If you need to access the same value within the child component, you should pass it as a different prop. (https://fb.me/react-special-props)
			
			
	範例
		function Item(props) {
			return (
				<li>{props.value}</li>
			);
		}

		function TodoList(props) {
			let list = props.list.map((value, index) => {
				return <Item key={index} value={value} />
			});
			return (
				<ul>{list}</ul>
			);
		}

		const array = ["JavaScript", "jQuery", "Node.js", "AngularJS", "React.js", "Vue.js"];

		ReactDOM.render(
			<TodoList list={array} />,
			document.getElementById("root")
		);
	
	
九. 表單

	受控組件(Controlled Component)
		簡述 : 值由React控制的輸入表單組件

		特徵
			1. 值 : 用屬性value控制
			2. 更新值 : 用onChage屬性控制 (通常指向組件class內另handleXyz方法)
			*註 : 以上兩點在組件class內, 都是props底下的特性
			
		範例
			class NameForm extends React.Component {
				constructor(props) {
					super(props);
					this.state = {name : undefined};	//此初始值會被<input>所使用, 設成null會有警告訊息, 設成undefined則不會
					this.handleChange = this.handleChange.bind(this);
					this.handleSubmit = this.handleSubmit.bind(this);
				}
				
				handleChange(event) {
					this.setState({name : event.target.value});
				}
				
				handleSubmit(event) {
					// 提交
					event.preventDefault();
				}
				
				render() {
					return (
						<form onSumit={this.handleSubmit}>
							<label>
								id :&nbsp;
								<input type="text" value={this.state.name} onChange={this.handleChange} />
							</label>
							<input type="submit" />
						</form>
					);
				}
			}

	React的<input type="checkbox" />
		語法
			<input type="checkbox" checked={值} />

		範例
			class CheckboxForm extends React.Component {
			    constructor(props) {
			        super(props);
			        this.state = {agreed : false};
			        this.handleChange = this.handleChange.bind(this);
			        this.handleSubmit = this.handleSubmit.bind(this);
			    }

			    handleChange(e) {
			        this.setState({agreed : e.target.checked});
			    }

			    handleSubmit(e) {
			        alert(`agreed : ${this.state.agreed}`);
			        e.preventDefault();
			    }

			    render() {
			        return (
			            <form onSubmit={this.handleSubmit}>
			                <input type="checkbox"
			                    checked={this.state.agreed}
			                    onChange={this.handleChange}/>
			                I agree
			                <br />
			                <input type="submit" value="Submit" />
			            </form>
			        );
			    }
			}

	React的<textarea>
		注意
			文字內容 : React的<textarea>透過屬性value設定 (原生HTML必需寫成 <textarea>xxx</textarea>)
			撰寫方式 : 單標籤
			
		語法
			<textarea value={值} />

		範例
			class TextAreaForm extends React.Component {
				constructor(props) {
				   super(props);
				   this.state = {
					   isFirst : true,
					   text : "list your skills of Java Framework"
				   };
					this.handleClick = this.handleClick.bind(this);
					this.handleChange = this.handleChange.bind(this);
				}

				handleClick(event) {
					if (this.state.isFirst) {
						event.target.value = "";
						this.setState({isFirst : false, text : ""});
					}
				}

				handleChange(event) {
					this.setState({text : event.target.value});
				}

				render() {
					return (
						<div>
							<textarea
								value={this.state.text}
								onClick={this.handleClick}
								onChange={this.handleChange} />
						</div>
					);
				}
			}

	React的<select> - <option>
		注意
			預選 : 使用value屬性, 而不使用原生HTML的selected屬性
			
		語法
			<select value={選取選項}>
				<option value="值1">選項1</option>
				<option value="值2">選項2</option>
				...
				<option value="值N">選項N</option>
			</select>

		範例
			class CityForm extends React.Component {
				constructor(props) {
					super(props);
					this.state = {city : "TPC"};	// 設定預選
					this.handleSubmit = this.handleSubmit.bind(this);
					this.handleChange = this.handleChange.bind(this);
				}

				handleSubmit(event) {
					let xhr = new XMLHttpRequest();
					const url = "http://localhost:8080/SpringHibernateLog4jDemo/memberRest/sendCity";
					xhr.open("POST", url, true);
					xhr.setRequestHeader("Content-Type", "application/json; charset=utf-8");
					xhr.send(JSON.stringify({city : this.state.city}));
					event.preventDefault();
				}

				handleChange(event) {
					this.setState({city : event.target.value});	// 不加此行不能改變選項
				}

				render() {
					return (
						<form onSubmit={this.handleSubmit}>
							<label>
								choose city
								<br />
								<select value={this.state.city} onChange={this.handleChange}>
									<option value="KLC">基隆市</option>
									<option value="TPC">台北市</option>
									<option value="NTPC">新北市</option>
									<option value="TYH">桃園市</option>
									<option value="HCT">新竹市</option>
									<option value="HCH">新竹縣</option>
								</select>
							</label>
							<br />
							<input type="submit" value="Submit" />
						</form>
					);
				}
			}

	React的<input type="file" />
		注意
			唯讀性 : 由於value屬性是唯讀的, 所以在React中屬於非受控組件. (待續..)
	
	多輸入處理
		注意
			設定name屬性, 使用event.target.name來識別
			
		範例 *註 : 此段程式有警告訊息(讓受控組件變成非受控組件), 未解(??)
			class MultiInputsForm extends React.Component {
				constructor(props) {
					super(props);
					this.state = {
						skills : {java : true, javascript : false},
						age : 30
					};
					this.handleInputChange = this.handleInputChange.bind(this);
				}

				handleInputChange(event) {
					let target = event.target;
					if (target.name === "skills") {
						this.setState({skills : {[target.value] : target.checked}});
					} else {
						this.setState({[target.name] : target.value});
					}
				}

				render() {
					return (
						<form>
							<label>
								choose skills
								<br />
								<input type="checkbox"
									   name="skills"
									   value="java"
									   checked={this.state.skills.java}
									   onChange={this.handleInputChange} />
								Java
								&nbsp;
								<input type="checkbox"
									   name="skills"
									   value="javascript"
									   checked={this.state.skills.javascript}
									   onChange={this.handleInputChange} />
								JavaScript
							</label>
							<br />
							<label>
								age
								<input type="number" value={this.state.age} name="age" onChange={this.handleInputChange} />
							</label>
							<br />
							<input type="submit" value="Submit" />
						</form>
					);
				}
			}

	替代方法 : 非受控組件


十. 狀態提升
	簡述 : 將狀態提升至最小的共同父組件內, 以達到兄弟組件間共享狀態
	
	作法 : 將子組件的state轉存至父組件state, 子組件不使用state而使用props

	範例 - 公斤<->磅 計算器 (改其中一單位之值, 另單位之值也會跟著改變)
		
		//子組件 - 輸入框
		class InputForm extends React.Component {
			constructor(props) {
				super(props);
				this.handleChange = this.handleChange.bind(this);
			}

			handleChange(e) {
				this.props.handleChange(e.target);
			}

			render() {
				return (
					<fieldset>
						<legend>{this.props.scale}</legend>		//<--使用props
						<input
							type="number"
							value={this.props.value}
							onChange={this.handleChange}		//<--使用props
							data-scale={this.props.scale} />	//<--使用props
					</fieldset>
				);
			}
		}

		// 父組件 - 計算器(含有兩個子組件)
		class Calculator extends React.Component {
			static TO_LB = 2.20462262;
			static TO_KG = 0.45359237;

			constructor() {
				super();
				this.state = {currScale : undefined, value : 0};		//<--子組件要用之值, 儲存在父組件的state
				this.handleChange = this.handleChange.bind(this);
			}

			handleChange(target) {
				this.setState({currScale : target.dataset.scale, value : target.value});
			}

			render() {
				const currScale = this.state.currScale;
				const value = this.state.value;

				let valueOfKg = currScale === "lb" ? Calculator.TO_KG * value : value;
				let valueOfLb = currScale === "kg" ? Calculator.TO_LB * value : value;

				return (
					<div>
						<InputForm scale="kg" value={valueOfKg} handleChange={this.handleChange} />
						<InputForm scale="lb" value={valueOfLb} handleChange={this.handleChange} />
					</div>
				);
			}
		}
		
	
十一. 組合 vs 繼承
	簡述 : 將組件模組化後, 利用"組合"的方式來重複利用組件
	
	注意
		1. React中使用組合, 而不用繼承
		2. 組建中可接受任何元素, 包括基本型態、函數、React元素
		3. 跟UI無關的程式碼, 應寫在組件外
		
	容器組件 : 其內可用多個內組件
	
		範例1 - 一個內組件, 使用特殊的props.children
			// 容器組件
			function Border(props) {
				return (
					<div style={{border : "solid 1px " + props.color}}>
						{props.children}			//<--因為有此行, 內組件才會被加進來
					</div>
				);
			}
			
			// 使用容器組件的組件
			function Dialog(props) {
				return (
					<Border color="blue">
						<h1>Hi, {props.name}</h1>	//<--對應上{props.children}
					</Border>
				);
			}
			
		範例2 - 多內組件, 自訂props.特性
			// 容器組件
			function Border(props) {
				return (
					<div style={{border : "solid 1px " + props.color}}>
						{props.up}			//<--因為有此行, 內組件才會被加進來
						<hr />
						{props.bottom}		//<--因為有此行, 內組件才會被加進來
					</div>
				);
			}
			
			// 使用容器組件的組件
				*註 : 此處寫成<Border /> "單"標籤
			
			function Dialog(props) {
				return (
					<Border color="red" up={
						<h1>Hi, {props.name}</h1>
					} bottom={
						<p>Welcome to React</p>
					} />
				);
			}
		
	特殊實例(Special Cases) : 由已存在組件延伸出的新組件. 在React中一樣使用"組合"來實踐, 而非繼承
		
		範例 - 由Dialog延伸出的WelcomeDialog
			// Dialog組件
			function Dialog(props) {
				return (
					<Border color="red" up={
						<h1>Hi, {props.name}</h1>
					} bottom={
						<p>{props.msg}</p>
					} />
				);
			}
			
			// WelcomeDialog組件
			function WelcomeDialog(props) {
				return (
					<Dialog name={props.name} msg="Welcome" />
				);
			}


十二. React實作分析
	步驟
		1. UI分析 : 由視覺稿定義出組件的命名、層級架構
		
		2. UI實作(排版) : 實作一個靜態版本

		3. 資料分析 : 分析出動態部分(state)
			考慮3個問題 (符合其中一點就不是state)
				3.1 由父組件傳來否(props)
				3.2 隨時間變化否
				3.3 可以靠其他state或props計算出否

		4. state歸屬分析 : state存放至何組件, 步驟
			4.1 確定需要此state的組件
			4.2 若多個組件需要此state, 找出最小共同父組件
			4.3 最小共同父組件擁有此state, 還是另外更高層組件應該擁有
			4.4 若更高層組件應該擁有此state, 就建立一個組件, 僅用來存此state, 且放至比最小共同父組件更高的層級
			
		5. 資料流分析
			5.1 事件觸發 : 由哪個子組件呼叫哪個父組件
			5.2 更新狀態 : setState()

	範例 - 列表 (含過濾功能)
		需求
			https://doc.react-china.org/static/thinking-in-react-components-eb8bda25806a89ebdc838813bdfa3601-82965.png

		步驟1 - UI分析
			FilterableProductTable (橙色)
				SearchBar (藍色)
				ProductTable (綠色)
					ProductCategoryRow (藍綠色)
					ProductRow (紅色)

		步驟2 - UI實作
			(略)
		
		步驟3 - 資料分析
			state.filterText : 過濾的文字
			state.isStockOnly : 只顯示有庫存否
			
		步驟4 - state歸屬分析
			state存至FilterableProductTable (最外圍容器)
			
		步驟5 - 資料流分析
			5.1 事件由子組件SearchBar觸發, 呼叫父組件FilterableProductTable的對應方法
			5.2 在父組件FilterableProductTable呼叫setSate()分別更新filterText和isStockOnly

		程式碼
			
			// 資料
			const products = [
				{category: "Sporting Goods", price: "$49.99", stocked: true, name: "Football"},
				{category: "Sporting Goods", price: "$9.99", stocked: true, name: "Baseball"},
				{category: "Sporting Goods", price: "$29.99", stocked: false, name: "Basketball"},
				{category: "Electronics", price: "$99.99", stocked: true, name: "iPod Touch"},
				{category: "Electronics", price: "$399.99", stocked: false, name: "iPhone 5"},
				{category: "Electronics", price: "$199.99", stocked: true, name: "Nexus 7"}
			];
			
			// 搜尋列組件
			class SearchBar extends React.Component {
				constructor(props) {
					super(props);
					this.handleFilter = this.handleFilter.bind(this);
					this.handleChecked = this.handleChecked.bind(this);
				}

				handleFilter(e) {
					this.props.handleFilter(e.target.value);
				}

				handleChecked(e) {
					this.props.handleChecked(e.target.checked);
				}

				render() {
					return (
						<div>
							<input type="text" placeholder="Search..." onChange={this.handleFilter}/>
							<br/>
							<input type="checkbox" onChange={this.handleChecked}/>
							Only show products in stock
						</div>
					);
				}
			}
			
			// 產品分類列組件
			function ProductCategoryRow(props) {
				return (
					<tr>
						<th colSpan="2">{props.category}</th>
					</tr>
				);
			}
			
			// 產品列組件
			function ProductRow(props) {
				let product = props.product;
				let name = product.stocked ? product.name : <span style={{color: "red"}}>{product.name}</span>
				return (
					<tr>
						<td>{name}</td>
						<td>{product.price}</td>
					</tr>
				);
			}
			
			// 產品列表組件
			function ProductTable(props) {
				let currCategory;
				let rows = [];
				products.forEach(product => {
					if (product.name.indexOf(props.filterText) === -1
						|| (props.isStockOnly && !product.stocked))
						return;

					let category = product["category"];
					if (currCategory !== category) {
						rows.push(<ProductCategoryRow category={product["category"]} key={product.category} />);
						currCategory = category;
					}
					rows.push(<ProductRow product={product} key={product.name}/>)
				});
				return (
					<table>
						<thead>
						<tr>
							<th>Name</th>
							<th>Price</th>
						</tr>
						</thead>
						<tbody>
						{rows}
						</tbody>
					</table>
				);
			}
			
			// 整個組件
			class FilterableProductTable extends React.Component {
				constructor(props) {
					super(props);
					this.state = {filterText: "", isStockOnly: false};
					this.handleFilter = this.handleFilter.bind(this);
					this.handleChecked = this.handleChecked.bind(this);
				}

				handleFilter(value) {
					this.setState({filterText: value})
				}

				handleChecked(checked) {
					this.setState({isStockOnly: checked})
				}

				render() {
					return (
						<div>
							<SearchBar handleFilter={this.handleFilter} handleChecked={this.handleChecked}/>
							<ProductTable filterText={this.state.filterText} isStockOnly={this.state.isStockOnly}/>
						</div>
					);
				}
			}


===========================================================================================================================
進階

深入JSX
	React元素的型態
		必需引入
			1. 只是React.createElement()語法糖
			
			2. <Xyz>會被編譯成同名的變數並被使用, 所以使用前必需先聲明. ex..
				SearchBar.js
					class SearchBar extends React.Component {
						...
					}
					
					export default SearchBar;				<--匯出
					
				Main.js
					import SearchBar from "./SearchBar";	<--引入
				
					ReactDOM.render(
						<SearchBar />,
						document,getElementById("root")
					);

				*註 : 如果使用<script>載入, 作用範圍是全局

		點表示法
			1. 定義時, React組件也可以巢狀包含, 形成內部React組件, ex..
				const MyComponents = {
					DatePicker: function DatePicker(props) {							<--定義內部組件
						return <div>Imagine a {props.color} datepicker here.</div>;
					}
				}
			2. 使用時, 使用點表示法, ex..
				function BlueDatePicker() {
					return <MyComponents.DatePicker color="blue" />;					<--使用點表示法
				}
			
		大寫開頭
			1. 小寫開頭為HTML原生標籤, ex. div、span
			2. 大小開頭為React組件, <Foo />會編譯為React.createElement(Foo)
			
		執行時期選擇React組件
			JSX角括弧中不能使用js的表達式(expression), 若要在執行時期動態選擇React元素, 需先指定給一大寫開頭的變數ex..
				function User1() {
					...
				}
				
				function User2() {
					...
				}
				
				const users = [User1, User2];
				let input = prompt();
				const User = users[input % 2];	<--一定要用大寫開頭的變數名
				
				ReactDOM.render(
					<User />,
					root
				);
			
	屬性指定方式
		方式1 - JavaScript表達式
			語法
				<元素 屬性={expression} />
				
			範例
				<Component name={1 + 2 + 3} />
		
		方式2 - 字串字面常數
			語法
				<元素 屬性="字串字面常數" />
			
			範例
				<Component name="william" />
				
			*註 : 會直接用HTML方式解析, ex..
				<Component name="&lt;3" />
				等同
				<Component name={"<3"} />
				
		方式3 - 不指定值
			說明 : 因預設值為true, 所以不只值的狀況下等同指定為true
		
			語法
				<元素 屬性 />
				
			範例
				<Component name />
				等同
				<Component name={true} />
				
		方式4 - 擴展	
			說明 : 傳遞屬性物件. 會自動用 屬性物件特性名 映射 屬性名
			
			語法
				<元素 {...屬性物件名}
		
			範例
				function User(props) {
					return (
						<div>name : {props.name}, age : {props.age}, birthday : {props.birthday}</div>
					);
				}
			
				const p1 = {name : "william", age : 30, birthday : new Date(1988, 0, 17).toDateString()};
		
				<User {...p1} />
		
	子元素指定方式 (props.children)
		方式1 - 字串字面常數
			語法
				<父元素>字串字面常數</父元素>
				
			*註 : JSX會"自動"去除頭尾的空白、Tab、換行; 字串字面常數中含有的換行則會被轉成一個空白
		
			範例 (以下四種寫法都是一樣的結果)
				<Welcome>Welcome to React</Welcome>
				
				// 去除頭尾的空白
				<Welcome>   Welcome to React   </Welcome>
				
				// 去除頭尾換行和Tab
				<Welcome>
					Welcome to React
				</Welcome>
				
				// 字串字面常數中的換行被轉成空白
				<Welcome>Welcome
				to
				React</Welcome>
				
		方式2 - JSX
			語法
				<父元素>
					<子元素1>
					<子元素2>
				</父元素>
				
			方式2.1 - 元素陣列
				語法
					[
						<元素1 />,
						<元素2 />,
						...,
						<元素N />
					];
					
				範例
					return [
						<li key="a">One</li>,
						<li key="b">Two</li>,
						<li key="c">Three</li>
					];
				
				
		方式3 - JavaScript表達式		
			語法
				<父元素>{expression}</父元素>
				
			範例
				<ul>
					{skillArr.map(v => {	//skillArr為一字串陣列
						<Item name={v} />
					})}
				</ul>
				
		方式4 - 函數
			說明 : 透過props.children傳遞function型態之參數
			
			語法
				<父元素>{函數名}</父元素>
				
			範例
				function UserList() {
					return (
						<User>
							{() => {
								return {name : "William", age : 30};	<--傳給子元素的
							}}
						</User>
					);
				}
				
				function User(props) {
					let o = props.children();	<--從父元素接收的function, 馬上呼叫拿到物件
					return (
						<li>name : {o.name}, age : {o.age}</li>
					);
				}
				
		方式5 - boolean、null、undefined
			說明 : boolean(false、true)、null和undefined不會被React渲染, 若要被渲染需用String()包含
				
			語法
				<父元素>{String(值)}</父元素>
				
			應用 - 當作判斷條件
				*註 : falsy家族的數字0可當作判斷條件, 但"會"被渲染, 加上Boolean()可避免
			
				範例
					// 假設showHeader是決定<Header>顯示否的變數
					<div>
						{Boolean(showHeader) && <Header />}
					</div>
					
				
使用prop-types進行型態檢查
	*註 : React v15.5前使用的是React.PropTypes. 因為重點用於開發階段, 所以v15.5後獨立另一套件
	
	簡述 : npm上的套件, 用以在執行時期檢查props, 但僅用console.warn()發出警告
		
	安裝
		npm install --save prop-types
	
	引入
		import PropTypes from 'prop-types'; // ES6
		var PropTypes = require('prop-types'); // ES5 with npm
		
	cdn (可自行修改版本)
		unpkg
			<!-- development version -->
			<script src="https://unpkg.com/prop-types@15.6/prop-types.js"></script>
			 
			<!-- production version -->
			<script src="https://unpkg.com/prop-types@15.6/prop-types.min.js"></script>
		cdnjs
			<!-- development version -->
			<script src="https://cdnjs.cloudflare.com/ajax/libs/prop-types/15.6.0/prop-types.js"></script>
			 
			<!-- production version -->
			<script src="https://cdnjs.cloudflare.com/ajax/libs/prop-types/15.6.0/prop-types.min.js"></script>
		
	語法
		組件名.propTypes = {
			特性名1 : PropTypes.檢查項目,
			特性名2 : PropTypes.檢查項目,
			...
			特性名N : PropTypes.檢查項目
		}

	檢查種類
		1. props的型態
		2. props的值
		3. props必需否
		
	檢查型態 (PropTypes.)
		JavaScript型態
			PropTypes.bool
			PropTypes.number
			PropTypes.string
			PropTypes.symbol
			PropTypes.array
			PropTypes.func
			PropTypes.object

		複合型態
			任何可被渲染的型態 (number、string、element、array、fragment)
				PropTypes.node

		React型態
			React element
				PropTypes.element

		自訂型態
			PropTypes.instanceOf(型態)

		子型態
			陣列元素型態 (含有一個以上)
				PropTypes.arrayOf(PropTypes.型態)

			物件特性型態 (含有一個以上)
				PropTypes.objectOf(PropTypes.型態)

			物件特性型態 (列舉)
				PropTypes.shape({
					特性1 : PropTypes.型態, 
					特性2 : PropTypes.型態, 
					...
					特性N : PropTypes.型態 
				})

		進階
			任何
				PropTypes.any

			列舉單選
				PropTypes.oneOf([型態1, 型態2, ..., 型態N])
				*註 : 參數可以是上述任何一個

				範例
					PropTypes.oneOfType([PropTypes.bool, PropTypes.instanceOf(Person)])

	檢查值
		PropTypes.oneOf([值1, 值2, ..., 值N])

	必需否
		PropTypes.型態.isRequired
			
	自訂驗證器
		注意
			1. 不符合時需return Error物件
			2. 不可用console.warn()和throw
			3. 不可用在PropTypes.oneOfType()

		一般驗證器

				function(props, propName, componentName) {
					if (!/matchme/.test(props[propName])) {
						return new Error('Invalid prop `' + propName + '` supplied to' + 
							' `' + componentName + '`. Validation failed.');
		    		}
				}
		
		arrayOf()用的驗證器

			function(propValue, key, componentName, location, propFullName) {
				if (!/matchme/.test(props[propName])) {
						return new Error('Invalid prop `' + propName + '` supplied to' + 
							' `' + componentName + '`. Validation failed.');
		    		}
			}

	單獨使用驗證(非用在React)
		語法
			PropTypes.checkPropTypes(檢查項目物件, 被檢查物件, "被檢查物件名", "組件名")
			*註 : "被檢查物件名" 跟 "組件名" 僅用在警告訊息顯示

		範例
			const myPropTypes = {
				name: PropTypes.string,
				age: PropTypes.number,
				// ...
			};

			const props = {
				name: 'hello', // is valid
  				age: 'world', // not valid
			};
		
			PropTypes.checkPropTypes(myPropTypes, props, 'props', 'Component1');
		
		
靜態型別檢查
	簡述 : 在編譯時期檢查型態. 許多此類框架都有自動完成功能, 所以很多人用來取代PropTypes		
		
	Flow
		說明 : JavaScript型態檢查器, 使用@Annotation, 經常跟React一起用
		*註 : Flow 本身就理解 JSX

		步驟
			1. 安裝
				Yarn
					yarn add --dev flow-bin

				npm
					npm install --save-dev flow-bin
		
			2. 將Flow加入專案 : 修改package.json
				{
					// ...
					"scripts": {
						"flow": "flow",
							// ...
					},
					// ...
				}

			3. 初始化(第一次)
				Yarn
					yarn run flow init

				npm
					npm run flow init

			4. 剝離Flow語法
				*註 : create-react-app : 預設已剝離

				npm install --save-dev babel-preset-flow
				npm install --global flow-remove-types
				npm install flow-remove-types

			5. 指定檢查檔案 : 在欲檢查程式檔頂部加上
				// @flow
		
			6. 執行
				Yarn
					yarn flow

				npm
					npm run flow
					*檢查全部檔案加上 --all

			7. 看訊息
			
	TypeScript
		說明 : JavaScript的延伸語言, 有自己的編譯器, 可在編譯時期發現錯誤

		步驟
			1. 安裝
				Yarn
					yarn add -dev typescript

				npm
					npm install --save-dev typescript
		
			2. 將Flow加入專案 : 修改package.json
				{
  					// ...
					"scripts": {
						"build": "tsc",
						// ...
					},
  					// ...
				}

				*註
					1. ref : https://github.com/Microsoft/TypeScript-React-Starter/blob/master/tsconfig.json
					2. 通常會把此檔案加至.gitignore
		
			3. 生成TypeScript組態檔 : tsconfig.json
				tsc --init
		
			4. 設定程式碼來源和目標 : 修改tsconfig.json
				{
					"compilerOptions": {
						// ...
						"rootDir": "src",
						"outDir": "build"
    					// ...
  					},
				}
		
			5. 執行
				Yarn
					yarn build

				npm
					npm run build

			6. 看訊息
				若沒訊息代表成功
		
		進階
			同時顯示來自其他框架的錯誤
				取得聲明文件
					Yarn
						yarn add --dev @types/react
			
					npm
						npm i --save-dev @types/react
		
				局部聲明
					1. 在src下建立declarations.d.ts
					2. 撰寫declarations.d.ts, ex..

						declare module 'querystring' {
							export function stringify(val: object): string
							export function parse(val: string): object
						}

			和 Create React App 一起使用 TypeScript
				create-react-app my-app --scripts-version=react-scripts-ts

	Others
		Reason

		Kotlin : React bindings、Create React Kotlin App

		F#/Fable : elmish-react


Refs & DOM
	簡述 : ref用以儲存在render()中建立的某個節點(HTML節點或React元素)

	*註 : 盡量避免使用ref 

	使用時機
		組件想操作自己包含的其中一個節點

	應用
		1. 處理焦點、選擇文字和媒體控制
		2. 觸發強制動畫
		3. 整合其他框架

	方式
		1. 一般式
		2. 函數式 (callback)

	一般式
		語法
			建立ref (在建構子裡)
				this.特性名 = React.createRef()

			指定節點
				<元素名 ref={this.特性名} />		// 特性名是 建立ref步驟 所指定

			取得節點
				this.特性名.current

			*註 : 組件用函數寫法不可用一般式

		底層動作
			在組件掛載(componentDidMount())時將結點傳入this.特性名.current, 卸載(componentDidUpdate())時再將此特性改為null

		範例一 - (操作自己的節點) click按鈕, 文字輸入框獲得焦點

			class InputForm extends React.Component {
			    constructor() {
			        super();
			        this.ref = React.createRef();	// 建立ref
			        this.handleClick = this.handleClick.bind(this);
			    }

			    handleClick() {
			        this.ref.current.focus();	// 取得節點, 並呼叫focus()
			    }

			    render() {
			        return (
			            <div>
			                <input type="text" ref={this.ref} />	// 指定節點
			                <input type="button" value="submit" onClick={this.handleClick} />
			            </div>
			        );
			    }
			}

		範例二 - (透過ref操作子節點) 父組件含有三個子組件, 掛載時自動讓第一個子組件獲得焦點

			// Child組件同範例一的InputForm組件
			class Child extends React.Component {
			    constructor() {
			        super();
			        this.ref = React.createRef();	// 建立子組件ref
			        this.handleClick = this.handleClick.bind(this);
			    }

			    handleClick() {
			        this.ref.current.focus();	// 取得節點, 並呼叫focus()
			    }

			    render() {
			        return (
			            <div>
			                <input type="text" ref={this.ref} />	// 指定節點
			                <input type="button" value="submit" onClick={this.handleClick} />
			            </div>
			        );
			    }
			}

			class FocusInputForm extends React.Component {
			    constructor(props) {
			        super(props);
			        this.ref = React.createRef();	// 建立父組件ref
			    }

			    componentDidMount() {
			        this.ref.current.handleClick();		// this.ref.current會取得第一個<Child>, 呼叫它的handleClick()
			    }

			    render() {
			        return (
			            <div>
			                <Child ref={this.ref} />	// 指定節點 (第一個子組件)
			                <Child />
			                <Child />
			            </div>
			        );
			    }
			}

	函數式 (callback)
		語法
			建立ref
				constructor() {
					super();

					this.變數名 = null; 		// 宣告一變數, 用以儲存ref之值
					this.方法名 = this.方法名.bind(this);	
				}

				方法名(element) {			// 定義callback方法
					this.變數名 = element;	// 將節點儲存起來
				}

			指定節點
				<元素名 ref={this.特性名} />		// 特性名是 建立ref步驟 所指定

			取得節點
				this.變數名

		底層動作
			在組件掛載(componentDidMount())時將結點傳入callback函數, 卸載(componentDidUpdate())時會再將null傳入callback函數

			*註
				問題 : 在更新期間callback函數會被呼叫"兩次", 第一次會傳入null. 第二是才是節點
				解法 : 將callback函數定義在類別裡, 且用bind()綁定

		範例
			class InputForm extends React.Component {
			    constructor() {
			        super();
			        this.ref = null;				// 宣告一變數, 用以儲存ref之值
			        this.setRef = this.setRef.bind(this);
			        this.handleClick = this.handleClick.bind(this);
			    }

			    setRef(element) {					// 定義callback方法
			        this.ref = element;				// 將節點儲存起來
			    }

			    handleClick() {
			        this.ref.focus();				// 取得節點, 並呼叫focus() 
			    }

			    render() {
			        return (
			            <div>
			                <input type="text" ref={this.setRef} />		// 指定節點
			                <input type="button" value="submit" onClick={this.handleClick} />
			            </div>
			        );
			    }
			}

	函數組件使用ref
		說明 : 函數組件因為沒有ref的實例, 所以不能用一般式, 但可用函數式(callback)

		語法
			function 組件名(props) {

				let ref;	// 宣告一變數, 用以儲存ref之值

				return (
					...
					<元素 ref={element => {		// 使用函數式(callback)
						ref = element;			// 將節點儲存起來
						...
					}} />
					...
				);
			}

		範例
			function CustomTextInput(props) {
			    let ref;	// 宣告一變數, 用以儲存ref之值

			    function handleClick() {
			        ref.focus();		// 呼叫節點的focus()
			    }

			    return (
			        <div>
			            <input type="text" ref={(input) => {	// 使用函數式(callback)
			                ref = input;						// 將節點儲存起來
			            }} />

			            <input type="button" value="GetFocus" onClick={handleClick} />
			        </div>
			    );
			}


非受控組件
	簡述 : 使用ref取得相關的節點, 再將節點用原生DOM方式處理
		*註 : 應盡量使用受控組件, 受控組件方式是將相關節點的資料存在this.state裡

	使用非受控組件的原因
		1. 簡短程式碼
		2. 已有大量JavaScript程式, 為了方便整合
		3. 需求非常簡單

	範例
		class InputForm extends React.Component {
		    constructor() {
		        super();
		        this.ref = React.createRef();		// 建立ref
		        this.handleSubmit = this.handleSubmit.bind(this);
		    }

		    handleSubmit(e) {
		        alert(`value : ${this.ref.current.value}`);		// 取得value
		        e.preventDefault();
		    }

		    render() {
		        return (
		            <form onSubmit={this.handleSubmit}>
		                <label>
		                    name
		                    <input type="text" ref={this.ref} />	// 指定節點
		                </label>
		                <input type="submit" value="Submit" />
		            </form>
		        );
		    }
		}

	初始值
		簡述 : 設定表單元素的初始值, 但又不監控值, 應使用defaultValue屬性

		對象
			<input />	*註 : 除了<input type="file" />
			<select>
			<textarea>

		語法
			<Xxx defaultValue="值">
			或
			<Xxx defaultValue={值}>

	特殊元素 - <input type="file" />
		特點
			1. 永遠是非受控組件
			2. 不能指定defaultValue屬性
			3. 只能取得File相關資訊和使用File API處理

		範例
			class InputForm extends React.Component {
			    constructor() {
			        super();
			        this.ref = React.createRef();		// 建立ref
			        this.handleSubmit = this.handleSubmit.bind(this);
			    }

			    handleSubmit(e) {
			        alert(`fileName : ${this.ref.current.files[1].name}`);	// 只能取得File相關資訊
			        e.preventDefault();
			    }

			    render() {
			        return (
			            <form onSubmit={this.handleSubmit}>
			                <label>
			                    file
			                    <input type="file" ref={this.ref} />	// 指定節點
			                </label>
			                <input type="submit" value="Submit" />
			            </form>
			        );
			    }
			}


性能優化
	使用prod版
		說明
			dev版含有很多開發過程中需要的警告訊息, 正式環境應使用壓縮過的prod版
			使用prod版在React Developer Tools會看到 "This page is using the production build of React." 的訊息 

			*註 : 在開發環境不要使用prod版

		無工具下使用
			直接加入..
				<script src="https://unpkg.com/react@15/dist/react.min.js"></script>
				<script src="https://unpkg.com/react-dom@15/dist/react-dom.min.js"></script>

			*註 : 以.min.js結尾的才是prod版

		在Create React App裡使用
			npm run build

			*註 : 專案在build資料夾裡

		在Brunch裡使用
			步驟1. 安裝uglify-js-brunch插件
				Yarn
					yarn add --dev uglify-js-brunch
				npm
					npm install --save-dev uglify-js-brunch

			步驟2. 產生prod版
				brunch build -p

				*註 : -p即為prod版的意思

		在Browserify裡使用
			步驟1. 安裝所需插件
				Yarn
					yarn add --dev bundle-collapser envify uglify-js uglifyify
				npm
					npm install --save-dev bundle-collapser envify uglify-js uglifyify

				註 : 各插件說明
					envify : 用來確保正確的編譯環境
					uglifyify : 用來移除dev版引入
					bundle-collapser : 將module ID換成簡單的數字
					uglify-js : 整合以上3項插件, 並壓縮產生最終版
						*註 : 插件名uglify-js, 文件名則是uglifyjs

			步驟2. 產生prod版, ex..
				browserify ./index.js \
				-g [ envify --NODE_ENV production ] \
				-g uglifyify \
				| uglifyjs --compress --mangle > ./bundle.js

		在Rollup裡使用
			步驟1. 安裝所需插件
				Yarn
					yarn add --dev rollup-plugin-commonjs rollup-plugin-replace rollup-plugin-uglify
				npm
					npm install --save-dev rollup-plugin-commonjs rollup-plugin-replace rollup-plugin-uglify

				註 : 各插件說明
					replace : 用來確保正確的編譯環境
					commonjs : 提供commonjs支援
					uglify-js : 整合以上2項插件, 並壓縮產生最終版


			步驟2. pluging config
				plugins: [
					// ...
					require('rollup-plugin-replace')({
						'process.env.NODE_ENV': JSON.stringify('production')
					}),
					require('rollup-plugin-commonjs')(),
  					require('rollup-plugin-uglify')(),
  					// ...
				]

		在Webpack裡使用
			步驟1. 配置所需插件
				new webpack.DefinePlugin({
					'process.env': {
						NODE_ENV: JSON.stringify('production')
					}
				}),
				new webpack.optimize.UglifyJsPlugin()

	Chrome 開發者工具
		*註 : Edge、IE亦支援

		用途
			1. 組件掛載、卸載狀況
			2. 組件有無錯誤更新
			3. 組件更新的深度和頻率

		使用步驟
			1. 暫時關閉擴充工具, 尤其React DevTools
				*註 : 擴充工具會影響跑出來的結果

			2. 用開發模式啟動React app

			3. 開啟 Chrome開發者工具 -> Performance分頁 -> 按Record按鈕(實心圓形) -> 錄製行為
				*註 : 超過20秒可能會有問題

			4. 停止錄製 : 按Stop按鈕

			5. 查看React events結果 : (在中間區塊) 展開"User Timing"
				*註 : 用Webstorm會在"Main"底下

	大列表虛擬化
		問題 : 渲染一個很大的列表, 導致滾動、點擊等操作反應變很差

		解法 : 只渲染可見部分

		實作 : React Virtualized
			https://bvaughn.github.io/react-virtualized/#/components/List

			安裝
				npm install react-virtualized --save

	避免重複渲染
		觀察渲染狀況
			1. 開啟渲染提示 : Chrome開發者工具 -> React -> (checkbox) Highlight Updates 打勾
			2. 操作, 渲染時border顏色會改變

		手動控制渲染
			說明 : 當組件的props或state改變時, React會自動比較新舊元素來決定需要更新否, 但某些狀況下希望能自己控制, 以提升速度

			語法 (在React.Component子類別內, override..)

				shouldComponentUpdate(nextProps, nextState) {
					...
					// 要更新 : return true
					// 不更新 : return false
				}

				*註 : return false就會阻止render()被呼叫

			shouldComponentUpdate()說明
				1. 為生命週期函數
				2. props或state被更新 -> shouldComponentUpdate() return true ? -> render()
				3. 樹狀結構裡, 若父節點的shouldComponentUpdate()回傳false, 子節點的shouldComponentUpdate()就"不會"被呼叫
			
			範例 : props.color或state.count改變時才重新渲染
				class CounterButton extends React.Component {
				    constructor(props) {
				        super(props);
				        this.state = {count: 1};
				    }

				    shouldComponentUpdate(nextProps, nextState) {		// <--
				        if (this.props.color !== nextProps.color) {
				            return true;
				        }
				        if (this.state.count !== nextState.count) {
				            return true;
				        }
				        return false;
				    }

				    render() {
				        return (
				            <button
				                color={this.props.color}
				                onClick={() => this.setState(state => ({count: state.count + 1}))}>
				                Count: {this.state.count}
				            </button>
				        );
				    }
				}

			使用React.PureComponent
				特點
					1. 比對方式 : 用"淺比對"來實作shouldComponentUpdate(), 不比對props和state的"值"
					2. 忽略 : 會忽略所有子節點的更新
					3. 使用時機 : 若需求為 相同的props值和state值 會渲染相同的結果時, 可用React.PureComponent來提升效能
					4. 複寫 : 理論上不可override shouldComponentUpdate(), 但若是複寫會出現只會出現警告訊息, 不影響功能

				範例 - "錯誤"的使用
					*註 : 因為this.state.dateTime是一個"物件", 淺比對只比對物件的"參考", 不比對其物件的內容, 所以不會重新渲染

					class MyComponent extends React.PureComponent {
					    constructor() {
					        super();
					        const date = new Date();
					        this.state = {dateTime : {date : date.toDateString(), time : date.toTimeString()}};
					    }

					    componentDidMount() {
					        setInterval(() => {
					            let dateTime = this.state.dateTime;
					            const date = new Date();
					            dateTime.date = date.toDateString();
					            dateTime.time = date.toTimeString();
					            this.setState({dateTime : dateTime});

					            // 改成以下三行就可解決問題
					            // const date = new Date();
					            // let dateTime = {date : date.toDateString(), time : date.toTimeString()};
					            // this.setState({dateTime : dateTime});
					        }, 1000);
					    }

					    render() {
					        return (
					            <div>
					                <h4>{this.state.dateTime.date}</h4>
					                <h4>{this.state.dateTime.time}</h4>
					            </div>
					        );
					    }
					}

			不突變資料(Not Mutating Data)
				簡述 : 一種做法, 指不改變原來的物件

				實作方式
					1. 使用Object.assign()
					2. 使用ES6展開運算子(spread operator)
					3. 使用Immutable.js
					4. seamless-immutable
					5. immutability-helper

				使用Object.assign()
					*註 : Object.assign(target, ...sources)會回傳一個新的物件

					範例 - 解決上例 - "錯誤"的使用, React.PureComponent不會更新的問題

					    componentDidMount() {
					        setInterval(() => {
					        	// dateTime是一個全新的物件
					            let dateTime = Object.assign({}, this.state.dateTime, {time : new Date().toTimeString()});
					            this.setState({dateTime : dateTime});
					        }, 1000);
					    }

				使用ES6展開運算子(spread operator)
					範例 - 解決上例 - "錯誤"的使用, React.PureComponent不會更新的問題

						componentDidMount() {
					        setInterval(() => {
					            this.setState({dateTime : {...this.state.dateTime, time : new Date().toTimeString()}});
					        }, 1000);
					    }

				使用Immutable.js
					Immutable.js的不可突變實作
						1. 物件一旦建立, 其內容就不能改變
						2. 想要做到改變內容, 就只能建立新物件

					安裝
						npm install immutable

					引入
						import ImmuTable from "immutable";

					範例 - 解決上例 - "錯誤"的使用, React.PureComponent不會更新的問題
						constructor() {
					        ...
					        // 用ImmuTable.Record()就好像建立一個DateTimeRecord類別
					        this.DateTimeRecord = ImmuTable.Record(this.state.dateTime);
					    }

					    componentDidMount() {
					        setInterval(() => {
					        	// 建立一個新的DateTimeRecord物件
					            let dateTime = new this.DateTimeRecord({time : new Date().toTimeString()});
					            this.setState({dateTime :dateTime});
					        }, 1000);
					    }


不使用ES6
	安裝
		npm install create-react-class

	引入
		var createReactClass = require("create-react-class");

	特點
		1. Props初始值 : 需寫成一函數getDefaultProps(), 並回傳物件
		2. State初始值 : 需寫成一函數getInitialState(), 並回傳物件
		3. 綁定 : 會自動綁定, 不需像類別式用bind()綁定

	語法
		var 組件名 = createReactClass({

			// Props初始值
			getDefaultProps : function() {
				return {
					特性名1 : 特性值1,
					特性名2 : 特性值2,
					...,
					特性名N : 特性值N
				};
			},

			// State初始值
			getInitialState : function() {
				return {
					特性名1 : 特性值1,
					特性名2 : 特性值2,
					...,
					特性名N : 特性值N
				};
			},

			// 生命週期方法
			生命週期方法名 : function() {
				...
			},

			...

			render : function() {
				...
				return (
					..JSX
				);
			}
		});

	混入(Mixin)
		說明 : mixins為React組件的特性, 為了橫切關注點所訂的特性. 橫切關注點 : 各組件間的相似功能

		特點
			1. 支援 : ES6本身沒有支援混入, 所以使用類別式就不能使用混入
			2. 多重混入 : 若一組件中加入多個混入物件, 可以使用的相同生命週期方法
			3. 執行順序 : 依定義時的順序

		語法
			定義混入物件
				var 混入物件名 = {
					函數/週期方法名1 : function(){},
					函數/週期方法名2 : function(){},
					...,
					函數/週期方法名N : function(){}
				};

			定義含有混入的組件
				var 組件名 = createReactClass({
					// 加入混入
					mixins : [混入物件名1, 混入物件名2, ..., 混入物件名N],

					某方法 : function() {
						this.函數/週期方法名();	// <-- 呼叫混入物件內的函數或週期方法
					},
					...
				});

		範例	 - Timer
			// 定義混入物件
			var mixins = {
				// 普通函數, 更新現在時間
			    updateTime : function() {
			        this.setState({time : new Date().toTimeString()});
			    },
			    // 生命週期方法, 註冊Timer
			    componentDidMount : function() {
			        let timerId = setInterval(this.updateTime, 1000);
			        this.setState({timerId : timerId});
			    },
			    // 生命週期方法, 註銷Timer
			    componentWillUnmount : function() {
			        clearInterval(this.state.timerId);
			    }
			};

			// 定義含有混入的組件
			var Timer = createReactClass({
			    mixins : [mixins],		//<-- 加入混入
			    getInitialState : function() {
			        return {time : new Date().toTimeString(), timeId : undefined};
			    },
			    render : function() {
			        return (
			            <h3>{this.state.time}</h3>
			        );
			    }
			});


不使用JSX
	簡述 : JSX是非必需的, 若不想安裝相關編譯器的話就用JavaScript寫法
		*註 : JSX只是React.createElement()的語法糖, 是靠Babel編譯器編譯成JavaScript

	語法
		render() {
			return React.createElement(type, [props], [...children]);
		}
		*註
			type : DOM元素/組件
			props : 傳給此DOM元素/組件的參數
			children : 子節點

	範例
		function User() {
			// JSX的 return (<div>{this.props.name}</div>); 等同以下..
			return React.createElement(
				"div",
				null,
				this.props.name
			);
		}

	簡短寫法插件
		1. react-hyperscript
		2. hyperscript-helpers


協調(Reconciliation)
	簡介 : React通過自有的對比演算法(Diffing Algorithm)來計算出是否需更新

	特點
		1. Optimal : 目前為止的最佳的演算法需要時間複雜度為O(n^3)
		2. React的簡算法 : React基於兩點假設, 開發出時間複雜度為O(n)的演算法
			2.1 不同類型就會產生不同的樹
			2.2 通過key屬性識別出哪些可能是穩定的元素

			*註 : 大部分的狀況下, 確實有用到以上兩點假設

	對比演算法 (比對兩顆樹, 分別代表舊組件跟新組件)
		根節點 => type相同 ? N => 更新樹
						   	Y => attribute相同 ?	 N => 更新attribute
											     Y => 子節點	<╝
											     	  ^	╚> 有無key attribute ? 	N => 依序比較 (效能差)
											     	  ∥				 ^		   	Y => 新有舊無 此key => 新增此節點
											     	  ∥				 ∥		   		 舊有新無 此key => 移除此節點
											     	  ∥				 ∥		   		 都有 => 有子節點 ? N => attribute相同 ? 	N ===============> 更新attribute
											     	  ╚==============∥================================ Y						Y => 	有下一個兄弟節點 ?	<╝
																	 ∥														 			╚> 	N => 結束
																	 ╚==========================================================兄弟節點 <=	Y


		其他細節
			1. 舊樹 : 會被卸載, 其舊節點會被銷毀 (componentWillUnmount()), 狀態亦被丟棄
			2. 新樹 : 會被加入至DOM, 依序呼叫componentWillMount()、componentDidMount()
			3. 更新組件流程
				3.1 保有原來的實例以保留state
				3.2 給新的props產生新元素
				3.3 呼叫componentReceiveProps()、componentWillUpdate()
				3.4 呼叫render()

	Keys
		問題 : 若是在列表的"開頭"插入一個新節點, 對比演算法會認為整個列表都變了, 更新整個列表, 以致效能變差

			// 舊樹
			<ul>
				<li>1</li>
				<li>2</li>
			</ul>

			// 新樹
			<ul>
				<li>0</li>	<-- 其實只多了此節點
				<li>1</li>
				<li>2</li>
			</ul>

		解法 : 加入key屬性, 對比演算法會用此屬性來做比對的依據, 以大幅提升效能

		注意
			1. 唯一性 : key在兄弟節點間必需唯一, 但不需全局唯一
			2. 用index : 若用陣列的索引當屬性key之值, 在列表重新排序時效能會變很差, 且可能導致錯誤
			3. 穩定、可預設的 : key屬性之值應該是穩定、可預設的, 若用Math.random()產生key屬性之值, 會導致進行不必要的重建及遺失state


Context
	簡述 : 跨組件層間共享資料的方式
		
	使用時機
		對組件樹來說的全局資料, ex. 當前登入使用者資料、Theme、預設語言

		*註 : 如果資料只是要在一兩層間共享, 其實不需要用到context

	語法
		建立
			const 上下文名 = React.createContext(Any defaultValue);

			說明
				回傳一個React.Context物件, 其中又包含Provider和Consumer兩物件

			範例
				const ThemeContext = React.createContext({color : "#222222"});

		使用
			提供端 (廣播)
				<上下文名.Provider value={共享值}>
					...	// 在這建立一些元素
				</上下文名.Provider>

				*註 : 在<上下文名.Provider>標籤之間的元素會收到共享值


			消費端 (訂閱)
				<上下文名.Consumer>
					{ (共享值) => {
							(...)	// 在這建立一些元素
						}
					}
				</上下文名.Consumer>

				*註
					1. Consumer從組件樹中最接近且匹配的上層Provider取得Context
					2. 若無符合則使用defaultValue
					3. 在<上下文名.Consumer>標籤之間用函數方式產生元素, 函數格式為
						function(Any sharedData){
							...
							return 元素;
						}

	注意事項
		1. Provider的value改變時, 所有的Consumers都會被重新渲染, 並使用Object.is(value1, value2)作為改變否的判斷依據
			*註 : 會有一些問題, 參考下面 多餘的渲染
		2. 一個Provider可連繫多個Consumers
		3. Provider可被嵌套, 以覆蓋組件樹更深層的值
		4. 組件樹中任一層之組件皆可透過函數更新Context
		5. 可一次用多個Context, 寫成嵌套
		6. 如果一個Context被很多組件消費, 可能需要寫很多code, 可用"高階組件"方式解決
			*註
				高階組件 : https://doc.react-china.org/docs/higher-order-components.html

	多餘的渲染
		問題 : Provider的value改變時, 所有的Consumers都會被重新渲染, 但因為Context使用"參考識別(reference identity)",
			   即就算不同的物件擁有同樣的值, 也會識別成不同, 導致多餘的渲染

		解法 : 將Provider的value提升到state裡

		範例
			class App extends React.Component {
				render() {
					return (
						<XxxContext.Provider value={{aaa : bbb}}>	<--每次都建立新的物件
							...
						</XxxContext.Provider>
					);
				}
			}

			改成

			class App extends React.Component {
				constructor() {
					super();
					this.state = {value : {aaa : bbb}};				<--將此值提升至state裡
				}

				render() {
					return (
						<XxxContext.Provider value={this.state.value}>	<--指向state
							...
						</XxxContext.Provider>
					);
				}
			}

	範例一 - 最外層組件分享Theme給最內層組件

		// 先定好的兩個Theme
		const themes = {
		    light: {
		        foreground: '#ffffff',
		        background: '#222222',
		    },
		    dark: {
		        foreground: '#000000',
		        background: '#eeeeee',
		    }
		};

		// 建立一個Context, 預設為先定好的themes.dark
		const ThemeContext = React.createContext(themes.dark);

		// (最內層組件) 定義一個組件, 為ThemeContext的消費端
		class ThemeButton extends React.Component {
		    render() {
		        return (
		            <ThemeContext.Consumer>		// <-- 訂閱ThemeContext
		                {theme => (				// <-- 用函數產生組件元素
		                    <button
		                        {...this.props}
		                        style={{color : theme.foreground, backgroundColor : theme.background}} />)
		                }
		            </ThemeContext.Consumer>
		        );
		    }
		}

		// (中層組件) 定義一個組件, 僅為了示範跨層共享資料, 無其他意義
		class ToolBar extends React.Component {
		    render() {
		        return (
		            <ThemeButton>Change Theme</ThemeButton>
		        );
		    }
		}

		// (最外層組件) 定義一個組件, 為ThemeContext的提供端
		class App extends React.Component {
		    constructor(props) {
		        super(props);
		        this.state = {theme : themes.light};
		    }

		    render() {
		        return (
		            <section>
		                <ThemeContext.Provider value={this.state.theme}>	<-- 廣播ThemeContext
		                    <ToolBar />
		                </ThemeContext.Provider>
		            </section>
		        );
		    }
		}

	範例二 - 內層組件更新Context (透過函數)

		const themes = {
		    light: {
		        foreground: '#ffffff',
		        background: '#222222',
		    },
		    dark: {
		        foreground: '#000000',
		        background: '#eeeeee',
		    }
		};

		// 建立一個Context, 預設為一個物件
		const ThemeContext = React.createContext({
			theme : themes.dark,	// 預設Theme
			toggleTheme : () => {}	// <button>的事件處理函數, 預設為空
		});

		// (最內層組件) 定義一個組件, 為ThemeContext的消費端
		class ThemeButton extends React.Component {
		    render() {
		        return (
		            <ThemeContext.Consumer>
		                {({theme, toggleTheme}) => (
		                    <button
		                        {...this.props}
		                        onClick={toggleTheme}	<-- 在內層用外層組件共享的函數當作事件處理器
		                        style={{color: theme.foreground, backgroundColor: theme.background}}/>)
		                }
		            </ThemeContext.Consumer>
		        );
		    }
		}

		// (中層組件) 定義一個組件, 僅為了示範跨層共享資料, 無其他意義
		class ToolBar extends React.Component {
		    render() {
		        return (
		            <ThemeButton>Change Theme</ThemeButton>
		        );
		    }
		}

		// (最外層組件) 定義一個組件, 為ThemeContext的提供端
		class App extends React.Component {
		    constructor(props) {
		        super(props);
		        this.toggleTheme = this.toggleTheme.bind(this);		// 綁定要放在設定state初始值之前
		        this.state = {theme: themes.light, toggleTheme : this.toggleTheme};		// state內含一函數
		    }

		    // click事件處理函數
		    toggleTheme() {
		        this.setState({theme : this.state.theme === themes.light ? themes.dark : themes.light});
		    }

		    render() {
		        return (
		            <section>
		                <ThemeContext.Provider value={this.state}>	<-- 廣播ThemeContext (直接共享state)
		                    <ToolBar/>
		                </ThemeContext.Provider>
		            </section>
		        );
		    }
		}

	範例三 - 多個Context

		// 建立兩個Context
		const ThemeContext = React.createContext(themes.dark);
		const UserContext = React.createContext({name : "guest", age : -1});

		// (內層組件) 定義一個組件, 為兩Context的消費端
		class ToolBar extends React.Component {
		    render() {
		        return (
		            <ThemeContext.Consumer>			<-- 訂閱ThemeContext
		                {theme => (
		                    <UserContext.Consumer>	<-- 訂閱UserContext. 兩Context成嵌套
		                        {user => (
		                            <div style={{color : theme.foreground, backgroundColor : theme.background}}>
		                                <span>{user.name}</span>
		                                &nbsp;
		                                <span>{user.age}</span>
		                            </div>
		                        )}
		                    </UserContext.Consumer>
		                )}
		            </ThemeContext.Consumer>
		        );
		    }
		}

		// (外層組件) 定義一個組件, 為兩Context的提供端
		class App extends React.Component {
		    constructor(props) {
		        super(props);
		        this.state = {
		            theme: themes.light,
		            user : {name : "william", age : 30}};
		    }

		    render() {
		        return (
		            <section>
		                <ThemeContext.Provider value={this.state.theme}>	<-- 廣播ThemeContext
		                    <UserContext.Provider value={this.state.user}>	<-- 廣播UserContext. 兩Context成嵌套
		                        <ToolBar />
		                    </UserContext.Provider>
		                </ThemeContext.Provider>
		            </section>
		        );
		    }
		}

	範例四 - 在生命週期方法中使用Context
		// 無直接的方式. 技巧為多加一中層組件, 這層組件改用參數方式往下傳遞, 各層說明如下..
		// 最內層組件 : 要在生命週期方法中使用Context的組件
		// 中層組件 : Context的消費端, 並以"參數"方式傳給最內層組件. 僅為了此技巧所加
		// 最外層組件 : Context的提供端

		// 建立一個Context, 預設為一個物件
		const ThemeContext = React.createContext({
		    theme: themes.dark,
		    toggleTheme: () => {}
		});

		// (最內層組件) 定義一個組件, 因為父組件(中層組件)用參數方式將ThemeContext傳給此組件, 所以此組件中皆可用this.props取得ThemeContext
		class ThemeButton extends React.Component {
		    componentWillMount() {
		        console.log(this.props);	// <--
		    }

		    componentDidMount() {
		        console.log(this.props);	// <--
		    }

		    componentWillUpdate(prevProps, prevState) {
		        console.log(this.props);	// <--
		        return true;
		    }

		    componentWillUnmount() {
		        console.log(this.props);	// <--
		    }

		    render() {
		        return (
		            <button
		                onClick={this.props.toggleTheme}
		                style={{color: this.props.theme.foreground, backgroundColor: this.props.theme.background}}>
		                {this.props.children}
		            </button>
		        );
		    }
		}

		// (中層組件) 定義一個組件, 為ThemeContext的消費端, 並且以"參數"方式傳給子組件
		class ToolBar extends React.Component {
		    render() {
		        return (
		            <ThemeContext.Consumer>				<--訂閱ThemeContext
		                {(context) => (
		                    <ThemeButton {...context}>	<--以參數方式傳給子組件
		                    	Change Theme
		                    </ThemeButton>
		                )}
		            </ThemeContext.Consumer>
		        );
		    }
		}

		// (最外層組件) 定義一個組件, 為ThemeContext的提供端
		class App extends React.Component {
		    constructor(props) {
		        super(props);
		        this.toggleTheme = this.toggleTheme.bind(this);
		        this.state = {theme: themes.light, toggleTheme: this.toggleTheme};
		    }

		    toggleTheme() {
		        this.setState({theme: this.state.theme === themes.light ? themes.dark : themes.light});
		    }

		    render() {
		        return (
		            <section>
		                <ThemeContext.Provider value={this.state}>		<-- 廣播ThemeContext
		                    <ToolBar />
		                </ThemeContext.Provider>
		            </section>
		        );
		    }
		}

	範例五 - 高階組件中的Context (獨立一個Context消費函數) 未完全看懂!!!!!!!!!!!!!!!!!!!!!!

		// 將消費ThemeContext獨立成一個"消費函數"
		function withTheme(Component) {
		    return function ThemedComponent(props) {	<--此props接不到值, 待確認?????
		        return (
		            <ThemeContext.Consumer>				<-- 訂閱ThemeContext
		                {theme =>
		                    (<Component theme={theme} />)
		                }
		            </ThemeContext.Consumer>
		        );
		    };
		}

		// 定義一個組件
		function Button(props) {
		    const theme = props.theme;
		    return <button style={{color : theme.foreground, backgroundColor : theme.background}} />;
		}

		// 組件Button會經由消費函數使用ThemeContext, 得到組件ThemeButton
		const ThemedButton = withTheme(Button);

		function App() {
		    return (
		        <ThemeContext.Provider value={themes.light}>	<-- 廣播ThemeContext 
		            <ThemedButton />
		        </ThemeContext.Provider>
		    );
		}

	範例六 - ??????


Fragments
	簡述 : 一個隱形的標籤, 可將"多個節點"聚成"一個元素", 然後用在列表中

	特點
		1. 隱形 : 網頁上不會看到<React.Fragment>
		2. key屬性 : <React.Fragment>只能有key屬性, 若無指定, 會看到警告訊息
		3. 簡易寫法 : <>為<React.Fragment>的語法糖, 但不能使用任何屬性
			*註 : 2018/06/14測試不能用!!

	語法
		標準寫法

			<React.Fragment key={鍵值}>
				元素1
				元素2
				...
				元素N
			</React.Fragment>

			ex.
				<React.Fragment>
					<dt>MyBatis</dt>
					<dd>Java ORM Framework</dd>
				</React.Fragment>

		簡易寫法

			<>
				元素1
				元素2
				...
				元素N
			</>

			ex.
				<>
					<dt>MyBatis</dt>
					<dd>Java ORM Framework</dd>
				</>

	範例
		class FrameworkList extends React.Component {
		    render() {
		        return (
		            <dl>
		                {this.props.items.map(item => (
		                    <React.Fragment key={item.id}>
		                        <dt>{item.text}</dt>
		                        <dd>{item.desc}</dd>
		                    </React.Fragment>
		                ))}
		            </dl>
		        );
		    }
		}


Portals
	簡述 : 將子節點(children)渲染到父組件以外某處的方式

	特點
		1. 可渲染至DOM中任何一處
		2. 行為 : 除第1點外, 其他行為與React子節點相同, React子節點能用的功能, Portal都能用
		3. 事件冒泡 : 是依組件樹層級, 非DOM樹

	應用
		1. 當父組件有style="overflow: hidden 或 z-index"時, 子組件跳出對話框、hovercards

	語法
		ReactDOM.createPortal(元素 child, 元素 container)



	範例一
		index.html
			<div id="root"></div>
			<div id="other" style="border: solid 3px red"></div>		<--網頁裡另一個容器

		index.js
			class Button extends React.Component {
				render() {
					return (
						<div>
							<button />
							{ReactDOM.createPortal(					<--渲染<Button>的
								this.props.children,				<--子元素
								document.getElementById("other"))}	<--到網頁裡另一個容器
						</div>
					);
				}
			}

			class App extends React.Component {
				render() {
					return (
						<Button>	
							Submit			<--指定<Button>的子元素
						</Button>
					);
				}
			}

			ReactDOM.render(
				<App />,
				document.getElementById("root")
			);



===========================================================================================================================
Arrow Function(箭頭函數)
	注意
		1. 沒有this、arguments、super、new.target
		2. 適用於匿名時
		3. 不能用在建構子
		4. 
		
	語法
		(參數1, 參數2, ..., 參數N) => {...}
		
		//本體只有一行時, 可省略{}, 那一行也自動會加上return
		(參數1, 參數2, ..., 參數N) => ...
		
		//只有一個參數時, 可省略()
		參數1 => {...}
		
		//但沒有參數時, 不可省略()
		() => {...}


雜
	1. ES6(arrow function、class、let、const)
	2. React元素就是一個js物件
	3. 在使用JavaScript classes時，你必須調用 super();方法才能在繼承父類的子類中正確獲取到類型的this
	4. JSX 元素的最外層套上了一小括號，以防止JavaScript 代碼在解析時自動在換行處添加分號
	5. 不可变性
		5.1 實現撤銷/重做以及時間旅行
		5.2 記錄變化
		5.3 React 當中判定何時重新渲染
	6. key	
		6.1 渲染列表項時，React 都會試著存儲對應每個單獨項的相關信息，如果你的組件包含state 狀態數據，那麼這些狀態數據必須被排序
		6.2 React 必須能夠知道是那一項改變了
		6.3 key是React當中使用的一種特殊的屬性（除此之外還有ref屬性），React會將元素的key值和對應元素綁定存儲起來。無法通過this.props.key獲取到key的值
		6.4 假如你不提供任何key值，React會提示警告，並且默認使用數組的索引作為默認的key 
		6.5 只需要在當前的節點裡保證唯一即可
	
	7. Property initializer syntax
		https://babeljs.io/docs/plugins/transform-class-properties/

		npm install --save-dev babel-plugin-transform-class-properties

		class 類別名 {
			特性名 = 值;
			方法名 = () => {
				...
			};

			static 靜態特性名 = 值;
			static 靜態方法名 = () => {
				...
			};

			// 方法也可以用箭頭函數 方法名 = () => {}
		}

	8. Computed property names (可計算屬性名)
	9. Shorthand初始化
		https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer#New_notations_in_ECMAScript_2015
	10. function* () {yield}
	11. import React, {Component} from "react";
	12. ES6 ...運算子 : 有兩種運算子, 都是寫成點點點
		1. 其餘運算子(rest operator) : 用在函數定義
			功能 : 多個變數/常數 => 陣列

			範例
				function avg(...arr) {
				    let sum = 0;
				    arr.forEach(value => sum += value);
				    console.log(`avg : ${sum / arr.length}`);
				}

				avg(1, 2, 3, 4);		// avg : 2.5

		2. 展開運算子(spread operator) : 用在呼叫函數/分配給另一陣列
			功能 : 陣列 => 多個變數/常數

			範例1
				var arr1 = [1, 2, 3, 4];
				console.log(arr1);		// [ 1, 2, 3, 4 ]
				console.log(...arr1);	// 1 2 3 4

			範例2
				var arr1 = [1, 2, 3, 4];
				var arr2 = [...arr1, 5];	// [1, 2, 3, 4, 5]

	13. export : 匯出函數、物件、原生型態之值至外部檔案, 外部檔案裡可用import引入來使用

		export default : 引入端可自訂名稱
			*註
				1. 一個js檔只能有一個
				2. 沒加default時, 引入端強制使用原來的名稱

			匯出端
				let name;
				export default name = "william";

			引入端
				import myName from "路徑加檔名";
				console.log(myName);	// "william"

		語法
			已先宣告
				export {名稱1, 名稱2, ..., 名稱N};
				export let 名稱1, 名稱2, ..., 名稱N;	// 亦可用var、const
					

			匯出同時宣告及指定值
				export {值1 as 名稱1, 值2 as 名稱2, ..., 值N as 名稱N};
				export let 名稱1 = 值1, 名稱2 = 值2, ..., 名稱N = 值N;	// 亦可用var、const
				export function 函數名(){...}
				export class 類別名 {...}

				未完!!!!!!!!!!!!!!!!!!!!

npm
	1. 全局安裝 -g
	2.
		npx create-react-app 專案名
		cd 專案名
		npm start
	3. 部屬上static server
			npm install -g serve
			serve -s build
	4. npm install xxx --save-dev
		安裝一個module時, 正常需要手動加至package.json, --save-dev即"自動"加至package.json,
		--save-dev : 自動加至devdependencies (開發環境)
		--save : 自動加至dependencies (正式環境)

class
	*註
		1. 此類別為React組件類別
		2. render()回傳React元素, 是想要渲染的內容描述

	class 類別名 extends React.Component {
		...
	
		render() {
			...
			return (...);
		}
	}
	
	render內容
		一般js寫法
			render() {
				return React.createElement('根標籤', {屬性1 : '值1'},
					React.createElement('子標籤1, {子子標籤...}),
					React.createElement('子標籤2, {子子標籤...}),
					...
					React.createElement('子標籤N, {子子標籤...})
				);
			}
			
		JSX寫法
			render() {
				//HTML語法
			}

Chrome React Tool
	https://reactjs.org/react-devtools-state-ef94afc3447d75cdc245c77efb0d63be.gif








			